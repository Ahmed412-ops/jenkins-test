import { $ as ur, $a as vr, A as H, Aa as ue, Ac as x, B as ge, Bc as ui, C as ee, Ca as mr, Cc as $e, Dc as di, E as ar, Ea as _n, Eb as ti, Ec as hi, F as me, Fa as _e, Fc as Fe, G as Cn, Ga as we, Gc as At, Ha as Re, I as ve, Ia as jn, J as te, Ja as $n, Jb as ri, K as cr, Ka as Fn, L as In, La as zn, M as An, Ma as Bn, Na as Vn, Nb as ni, O as Mn, Oa as qn, P as k, Pa as de, Pb as ii, Pc as fi, Q as Dn, Qb as si, R as M, Rc as Mt, S as C, Sc as pi, Ta as Gn, Tc as Dt, U as w, V as mt, Va as je, W as On, X as E, Xa as z, Y as lr, Ya as Wn, Z as v, _ as f, _a as Hn, a as h, aa as Pn, ab as Xn, b as P, ba as Le, bb as Jn, cb as Zn, da as Nn, db as yr, e as rr, ea as le, eb as Kn, f as Rn, fa as $, fb as wt, g as Sn, gb as Rt, h as nr, ha as vt, i as ir, j as sr, jb as Yn, k as Y, l as j, la as dr, lb as St, m as Q, ma as xn, mb as Qn, mc as Et, n as O, na as hr, nb as wr, o as p, oc as Ct, p as Ue, pb as bt, pc as oi, q as bn, qa as yt, qb as Tt, qc as It, r as Tn, ra as ye, rb as ei, s as S, sa as q, t as gt, ta as fr, u as U, v as ke, va as Un, w as En, wa as pr, wc as ai, x as or, xa as kn, xc as Rr, ya as gr, yc as ci, za as Ln, zc as li } from "./chunk-EQZPNU3V.js"; var Be = class { }, Pt = class { }, X = class t {
    headers; normalizedNames = new Map; lazyInit; lazyUpdate = null; constructor(r) {
        r ? typeof r == "string" ? this.lazyInit = () => {
            this.headers = new Map, r.split(`
`).forEach(e => { let n = e.indexOf(":"); if (n > 0) { let i = e.slice(0, n), s = e.slice(n + 1).trim(); this.addHeaderEntry(i, s) } })
        } : typeof Headers < "u" && r instanceof Headers ? (this.headers = new Map, r.forEach((e, n) => { this.addHeaderEntry(n, e) })) : this.lazyInit = () => { this.headers = new Map, Object.entries(r).forEach(([e, n]) => { this.setHeaderEntries(e, n) }) } : this.headers = new Map
    } has(r) { return this.init(), this.headers.has(r.toLowerCase()) } get(r) { this.init(); let e = this.headers.get(r.toLowerCase()); return e && e.length > 0 ? e[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(r) { return this.init(), this.headers.get(r.toLowerCase()) || null } append(r, e) { return this.clone({ name: r, value: e, op: "a" }) } set(r, e) { return this.clone({ name: r, value: e, op: "s" }) } delete(r, e) { return this.clone({ name: r, value: e, op: "d" }) } maybeSetNormalizedName(r, e) { this.normalizedNames.has(e) || this.normalizedNames.set(e, r) } init() { this.lazyInit && (this.lazyInit instanceof t ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(r => this.applyUpdate(r)), this.lazyUpdate = null)) } copyFrom(r) { r.init(), Array.from(r.headers.keys()).forEach(e => { this.headers.set(e, r.headers.get(e)), this.normalizedNames.set(e, r.normalizedNames.get(e)) }) } clone(r) { let e = new t; return e.lazyInit = this.lazyInit && this.lazyInit instanceof t ? this.lazyInit : this, e.lazyUpdate = (this.lazyUpdate || []).concat([r]), e } applyUpdate(r) { let e = r.name.toLowerCase(); switch (r.op) { case "a": case "s": let n = r.value; if (typeof n == "string" && (n = [n]), n.length === 0) return; this.maybeSetNormalizedName(r.name, e); let i = (r.op === "a" ? this.headers.get(e) : void 0) || []; i.push(...n), this.headers.set(e, i); break; case "d": let s = r.value; if (!s) this.headers.delete(e), this.normalizedNames.delete(e); else { let o = this.headers.get(e); if (!o) return; o = o.filter(c => s.indexOf(c) === -1), o.length === 0 ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, o) } break } } addHeaderEntry(r, e) { let n = r.toLowerCase(); this.maybeSetNormalizedName(r, n), this.headers.has(n) ? this.headers.get(n).push(e) : this.headers.set(n, [e]) } setHeaderEntries(r, e) { let n = (Array.isArray(e) ? e : [e]).map(s => s.toString()), i = r.toLowerCase(); this.headers.set(i, n), this.maybeSetNormalizedName(r, i) } forEach(r) { this.init(), Array.from(this.normalizedNames.keys()).forEach(e => r(this.normalizedNames.get(e), this.headers.get(e))) }
}; var br = class { encodeKey(r) { return gi(r) } encodeValue(r) { return gi(r) } decodeKey(r) { return decodeURIComponent(r) } decodeValue(r) { return decodeURIComponent(r) } }; function xs(t, r) { let e = new Map; return t.length > 0 && t.replace(/^\?/, "").split("&").forEach(i => { let s = i.indexOf("="), [o, c] = s == -1 ? [r.decodeKey(i), ""] : [r.decodeKey(i.slice(0, s)), r.decodeValue(i.slice(s + 1))], a = e.get(o) || []; a.push(c), e.set(o, a) }), e } var Us = /%(\d[a-f0-9])/gi, ks = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "3D": "=", "3F": "?", "2F": "/" }; function gi(t) { return encodeURIComponent(t).replace(Us, (r, e) => ks[e] ?? r) } function Ot(t) { return `${t}` } var ne = class t { map; encoder; updates = null; cloneFrom = null; constructor(r = {}) { if (this.encoder = r.encoder || new br, r.fromString) { if (r.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = xs(r.fromString, this.encoder) } else r.fromObject ? (this.map = new Map, Object.keys(r.fromObject).forEach(e => { let n = r.fromObject[e], i = Array.isArray(n) ? n.map(Ot) : [Ot(n)]; this.map.set(e, i) })) : this.map = null } has(r) { return this.init(), this.map.has(r) } get(r) { this.init(); let e = this.map.get(r); return e ? e[0] : null } getAll(r) { return this.init(), this.map.get(r) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(r, e) { return this.clone({ param: r, value: e, op: "a" }) } appendAll(r) { let e = []; return Object.keys(r).forEach(n => { let i = r[n]; Array.isArray(i) ? i.forEach(s => { e.push({ param: n, value: s, op: "a" }) }) : e.push({ param: n, value: i, op: "a" }) }), this.clone(e) } set(r, e) { return this.clone({ param: r, value: e, op: "s" }) } delete(r, e) { return this.clone({ param: r, value: e, op: "d" }) } toString() { return this.init(), this.keys().map(r => { let e = this.encoder.encodeKey(r); return this.map.get(r).map(n => e + "=" + this.encoder.encodeValue(n)).join("&") }).filter(r => r !== "").join("&") } clone(r) { let e = new t({ encoder: this.encoder }); return e.cloneFrom = this.cloneFrom || this, e.updates = (this.updates || []).concat(r), e } init() { this.map === null && (this.map = new Map), this.cloneFrom !== null && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(r => this.map.set(r, this.cloneFrom.map.get(r))), this.updates.forEach(r => { switch (r.op) { case "a": case "s": let e = (r.op === "a" ? this.map.get(r.param) : void 0) || []; e.push(Ot(r.value)), this.map.set(r.param, e); break; case "d": if (r.value !== void 0) { let n = this.map.get(r.param) || [], i = n.indexOf(Ot(r.value)); i !== -1 && n.splice(i, 1), n.length > 0 ? this.map.set(r.param, n) : this.map.delete(r.param) } else { this.map.delete(r.param); break } } }), this.cloneFrom = this.updates = null) } }; var Tr = class { map = new Map; set(r, e) { return this.map.set(r, e), this } get(r) { return this.map.has(r) || this.map.set(r, r.defaultValue()), this.map.get(r) } delete(r) { return this.map.delete(r), this } has(r) { return this.map.has(r) } keys() { return this.map.keys() } }; function Ls(t) { switch (t) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } } function mi(t) { return typeof ArrayBuffer < "u" && t instanceof ArrayBuffer } function vi(t) { return typeof Blob < "u" && t instanceof Blob } function yi(t) { return typeof FormData < "u" && t instanceof FormData } function _s(t) { return typeof URLSearchParams < "u" && t instanceof URLSearchParams } var ze = class t { url; body = null; headers; context; reportProgress = !1; withCredentials = !1; responseType = "json"; method; params; urlWithParams; transferCache; constructor(r, e, n, i) { this.url = e, this.method = r.toUpperCase(); let s; if (Ls(this.method) || i ? (this.body = n !== void 0 ? n : null, s = i) : s = n, s && (this.reportProgress = !!s.reportProgress, this.withCredentials = !!s.withCredentials, s.responseType && (this.responseType = s.responseType), s.headers && (this.headers = s.headers), s.context && (this.context = s.context), s.params && (this.params = s.params), this.transferCache = s.transferCache), this.headers ??= new X, this.context ??= new Tr, !this.params) this.params = new ne, this.urlWithParams = e; else { let o = this.params.toString(); if (o.length === 0) this.urlWithParams = e; else { let c = e.indexOf("?"), a = c === -1 ? "?" : c < e.length - 1 ? "&" : ""; this.urlWithParams = e + a + o } } } serializeBody() { return this.body === null ? null : typeof this.body == "string" || mi(this.body) || vi(this.body) || yi(this.body) || _s(this.body) ? this.body : this.body instanceof ne ? this.body.toString() : typeof this.body == "object" || typeof this.body == "boolean" || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return this.body === null || yi(this.body) ? null : vi(this.body) ? this.body.type || null : mi(this.body) ? null : typeof this.body == "string" ? "text/plain" : this.body instanceof ne ? "application/x-www-form-urlencoded;charset=UTF-8" : typeof this.body == "object" || typeof this.body == "number" || typeof this.body == "boolean" ? "application/json" : null } clone(r = {}) { let e = r.method || this.method, n = r.url || this.url, i = r.responseType || this.responseType, s = r.transferCache ?? this.transferCache, o = r.body !== void 0 ? r.body : this.body, c = r.withCredentials ?? this.withCredentials, a = r.reportProgress ?? this.reportProgress, l = r.headers || this.headers, u = r.params || this.params, d = r.context ?? this.context; return r.setHeaders !== void 0 && (l = Object.keys(r.setHeaders).reduce((m, b) => m.set(b, r.setHeaders[b]), l)), r.setParams && (u = Object.keys(r.setParams).reduce((m, b) => m.set(b, r.setParams[b]), u)), new t(e, n, o, { params: u, headers: l, context: d, reportProgress: a, responseType: i, withCredentials: c, transferCache: s }) } }, ie = function (t) { return t[t.Sent = 0] = "Sent", t[t.UploadProgress = 1] = "UploadProgress", t[t.ResponseHeader = 2] = "ResponseHeader", t[t.DownloadProgress = 3] = "DownloadProgress", t[t.Response = 4] = "Response", t[t.User = 5] = "User", t }(ie || {}), Ve = class { headers; status; statusText; url; ok; type; constructor(r, e = 200, n = "OK") { this.headers = r.headers || new X, this.status = r.status !== void 0 ? r.status : e, this.statusText = r.statusText || n, this.url = r.url || null, this.ok = this.status >= 200 && this.status < 300 } }, Nt = class t extends Ve { constructor(r = {}) { super(r) } type = ie.ResponseHeader; clone(r = {}) { return new t({ headers: r.headers || this.headers, status: r.status !== void 0 ? r.status : this.status, statusText: r.statusText || this.statusText, url: r.url || this.url || void 0 }) } }, qe = class t extends Ve { body; constructor(r = {}) { super(r), this.body = r.body !== void 0 ? r.body : null } type = ie.Response; clone(r = {}) { return new t({ body: r.body !== void 0 ? r.body : this.body, headers: r.headers || this.headers, status: r.status !== void 0 ? r.status : this.status, statusText: r.statusText || this.statusText, url: r.url || this.url || void 0 }) } }, re = class extends Ve { name = "HttpErrorResponse"; message; error; ok = !1; constructor(r) { super(r, 0, "Unknown Error"), this.status >= 200 && this.status < 300 ? this.message = `Http failure during parsing for ${r.url || "(unknown url)"}` : this.message = `Http failure response for ${r.url || "(unknown url)"}: ${r.status} ${r.statusText}`, this.error = r.error || null } }, bi = 200, js = 204; function Sr(t, r) { return { body: r, headers: t.headers, context: t.context, observe: t.observe, params: t.params, reportProgress: t.reportProgress, responseType: t.responseType, withCredentials: t.withCredentials, transferCache: t.transferCache } } var Ar = (() => { class t { handler; constructor(e) { this.handler = e } request(e, n, i = {}) { let s; if (e instanceof ze) s = e; else { let a; i.headers instanceof X ? a = i.headers : a = new X(i.headers); let l; i.params && (i.params instanceof ne ? l = i.params : l = new ne({ fromObject: i.params })), s = new ze(e, n, i.body !== void 0 ? i.body : null, { headers: a, context: i.context, params: l, reportProgress: i.reportProgress, responseType: i.responseType || "json", withCredentials: i.withCredentials, transferCache: i.transferCache }) } let o = p(s).pipe(ee(a => this.handler.handle(a))); if (e instanceof ze || i.observe === "events") return o; let c = o.pipe(H(a => a instanceof qe)); switch (i.observe || "body") { case "body": switch (s.responseType) { case "arraybuffer": return c.pipe(S(a => { if (a.body !== null && !(a.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return a.body })); case "blob": return c.pipe(S(a => { if (a.body !== null && !(a.body instanceof Blob)) throw new Error("Response is not a Blob."); return a.body })); case "text": return c.pipe(S(a => { if (a.body !== null && typeof a.body != "string") throw new Error("Response is not a string."); return a.body })); case "json": default: return c.pipe(S(a => a.body)) }case "response": return c; default: throw new Error(`Unreachable: unhandled observe type ${i.observe}}`) } } delete(e, n = {}) { return this.request("DELETE", e, n) } get(e, n = {}) { return this.request("GET", e, n) } head(e, n = {}) { return this.request("HEAD", e, n) } jsonp(e, n) { return this.request("JSONP", e, { params: new ne().append(n, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(e, n = {}) { return this.request("OPTIONS", e, n) } patch(e, n, i = {}) { return this.request("PATCH", e, Sr(i, n)) } post(e, n, i = {}) { return this.request("POST", e, Sr(i, n)) } put(e, n, i = {}) { return this.request("PUT", e, Sr(i, n)) } static \u0275fac = function (n) { return new (n || t)(v(Be)) }; static \u0275prov = w({ token: t, factory: t.\u0275fac }) } return t })(), $s = /^\)\]\}',?\n/, Fs = "X-Request-URL"; function wi(t) { if (t.url) return t.url; let r = Fs.toLocaleLowerCase(); return t.headers.get(r) } var zs = (() => { class t { fetchImpl = f(Er, { optional: !0 })?.fetch ?? ((...e) => globalThis.fetch(...e)); ngZone = f(q); handle(e) { return new nr(n => { let i = new AbortController; return this.doRequest(e, i.signal, n).then(Cr, s => n.error(new re({ error: s }))), () => i.abort() }) } doRequest(e, n, i) { return rr(this, null, function* () { let s = this.createRequestInit(e), o; try { let b = this.ngZone.runOutsideAngular(() => this.fetchImpl(e.urlWithParams, h({ signal: n }, s))); Bs(b), i.next({ type: ie.Sent }), o = yield b } catch (b) { i.error(new re({ error: b, status: b.status ?? 0, statusText: b.statusText, url: e.urlWithParams, headers: b.headers })); return } let c = new X(o.headers), a = o.statusText, l = wi(o) ?? e.urlWithParams, u = o.status, d = null; if (e.reportProgress && i.next(new Nt({ headers: c, status: u, statusText: a, url: l })), o.body) { let b = o.headers.get("content-length"), A = [], R = o.body.getReader(), y = 0, N, K, I = typeof Zone < "u" && Zone.current; yield this.ngZone.runOutsideAngular(() => rr(this, null, function* () { for (; ;) { let { done: ce, value: xe } = yield R.read(); if (ce) break; if (A.push(xe), y += xe.length, e.reportProgress) { K = e.responseType === "text" ? (K ?? "") + (N ??= new TextDecoder).decode(xe, { stream: !0 }) : void 0; let wn = () => i.next({ type: ie.DownloadProgress, total: b ? +b : void 0, loaded: y, partialText: K }); I ? I.run(wn) : wn() } } })); let Ne = this.concatChunks(A, y); try { let ce = o.headers.get("Content-Type") ?? ""; d = this.parseBody(e, Ne, ce) } catch (ce) { i.error(new re({ error: ce, headers: new X(o.headers), status: o.status, statusText: o.statusText, url: wi(o) ?? e.urlWithParams })); return } } u === 0 && (u = d ? bi : 0), u >= 200 && u < 300 ? (i.next(new qe({ body: d, headers: c, status: u, statusText: a, url: l })), i.complete()) : i.error(new re({ error: d, headers: c, status: u, statusText: a, url: l })) }) } parseBody(e, n, i) { switch (e.responseType) { case "json": let s = new TextDecoder().decode(n).replace($s, ""); return s === "" ? null : JSON.parse(s); case "text": return new TextDecoder().decode(n); case "blob": return new Blob([n], { type: i }); case "arraybuffer": return n.buffer } } createRequestInit(e) { let n = {}, i = e.withCredentials ? "include" : void 0; if (e.headers.forEach((s, o) => n[s] = o.join(",")), e.headers.has("Accept") || (n.Accept = "application/json, text/plain, */*"), !e.headers.has("Content-Type")) { let s = e.detectContentTypeHeader(); s !== null && (n["Content-Type"] = s) } return { body: e.serializeBody(), method: e.method, headers: n, credentials: i } } concatChunks(e, n) { let i = new Uint8Array(n), s = 0; for (let o of e) i.set(o, s), s += o.length; return i } static \u0275fac = function (n) { return new (n || t) }; static \u0275prov = w({ token: t, factory: t.\u0275fac }) } return t })(), Er = class { }; function Cr() { } function Bs(t) { t.then(Cr, Cr) } function Vs(t, r) { return r(t) } function qs(t, r, e) { return (n, i) => $(e, () => r(n, s => t(s, i))) } var Mr = new E(""), Gs = new E(""), Ws = new E("", { providedIn: "root", factory: () => !0 }); var Ri = (() => { class t extends Be { backend; injector; chain = null; pendingTasks = f(yt); contributeToStability = f(Ws); constructor(e, n) { super(), this.backend = e, this.injector = n } handle(e) { if (this.chain === null) { let n = Array.from(new Set([...this.injector.get(Mr), ...this.injector.get(Gs, [])])); this.chain = n.reduceRight((i, s) => qs(i, s, this.injector), Vs) } if (this.contributeToStability) { let n = this.pendingTasks.add(); return this.chain(e, i => this.backend.handle(i)).pipe(ve(() => this.pendingTasks.remove(n))) } else return this.chain(e, n => this.backend.handle(n)) } static \u0275fac = function (n) { return new (n || t)(v(Pt), v(le)) }; static \u0275prov = w({ token: t, factory: t.\u0275fac }) } return t })(); var Hs = /^\)\]\}',?\n/; function Xs(t) { return "responseURL" in t && t.responseURL ? t.responseURL : /^X-Request-URL:/m.test(t.getAllResponseHeaders()) ? t.getResponseHeader("X-Request-URL") : null } var Si = (() => { class t { xhrFactory; constructor(e) { this.xhrFactory = e } handle(e) { if (e.method === "JSONP") throw new C(-2800, !1); let n = this.xhrFactory; return (n.\u0275loadImpl ? O(n.\u0275loadImpl()) : p(null)).pipe(k(() => new nr(s => { let o = n.build(); if (o.open(e.method, e.urlWithParams), e.withCredentials && (o.withCredentials = !0), e.headers.forEach((R, y) => o.setRequestHeader(R, y.join(","))), e.headers.has("Accept") || o.setRequestHeader("Accept", "application/json, text/plain, */*"), !e.headers.has("Content-Type")) { let R = e.detectContentTypeHeader(); R !== null && o.setRequestHeader("Content-Type", R) } if (e.responseType) { let R = e.responseType.toLowerCase(); o.responseType = R !== "json" ? R : "text" } let c = e.serializeBody(), a = null, l = () => { if (a !== null) return a; let R = o.statusText || "OK", y = new X(o.getAllResponseHeaders()), N = Xs(o) || e.url; return a = new Nt({ headers: y, status: o.status, statusText: R, url: N }), a }, u = () => { let { headers: R, status: y, statusText: N, url: K } = l(), I = null; y !== js && (I = typeof o.response > "u" ? o.responseText : o.response), y === 0 && (y = I ? bi : 0); let Ne = y >= 200 && y < 300; if (e.responseType === "json" && typeof I == "string") { let ce = I; I = I.replace(Hs, ""); try { I = I !== "" ? JSON.parse(I) : null } catch (xe) { I = ce, Ne && (Ne = !1, I = { error: xe, text: I }) } } Ne ? (s.next(new qe({ body: I, headers: R, status: y, statusText: N, url: K || void 0 })), s.complete()) : s.error(new re({ error: I, headers: R, status: y, statusText: N, url: K || void 0 })) }, d = R => { let { url: y } = l(), N = new re({ error: R, status: o.status || 0, statusText: o.statusText || "Unknown Error", url: y || void 0 }); s.error(N) }, m = !1, b = R => { m || (s.next(l()), m = !0); let y = { type: ie.DownloadProgress, loaded: R.loaded }; R.lengthComputable && (y.total = R.total), e.responseType === "text" && o.responseText && (y.partialText = o.responseText), s.next(y) }, A = R => { let y = { type: ie.UploadProgress, loaded: R.loaded }; R.lengthComputable && (y.total = R.total), s.next(y) }; return o.addEventListener("load", u), o.addEventListener("error", d), o.addEventListener("timeout", d), o.addEventListener("abort", d), e.reportProgress && (o.addEventListener("progress", b), c !== null && o.upload && o.upload.addEventListener("progress", A)), o.send(c), s.next({ type: ie.Sent }), () => { o.removeEventListener("error", d), o.removeEventListener("abort", d), o.removeEventListener("load", u), o.removeEventListener("timeout", d), e.reportProgress && (o.removeEventListener("progress", b), c !== null && o.upload && o.upload.removeEventListener("progress", A)), o.readyState !== o.DONE && o.abort() } }))) } static \u0275fac = function (n) { return new (n || t)(v(Dt)) }; static \u0275prov = w({ token: t, factory: t.\u0275fac }) } return t })(), Ti = new E(""), Js = "XSRF-TOKEN", Zs = new E("", { providedIn: "root", factory: () => Js }), Ks = "X-XSRF-TOKEN", Ys = new E("", { providedIn: "root", factory: () => Ks }), xt = class { }, Qs = (() => { class t { doc; platform; cookieName; lastCookieString = ""; lastToken = null; parseCount = 0; constructor(e, n, i) { this.doc = e, this.platform = n, this.cookieName = i } getToken() { if (this.platform === "server") return null; let e = this.doc.cookie || ""; return e !== this.lastCookieString && (this.parseCount++, this.lastToken = At(e, this.cookieName), this.lastCookieString = e), this.lastToken } static \u0275fac = function (n) { return new (n || t)(v(x), v(ue), v(Zs)) }; static \u0275prov = w({ token: t, factory: t.\u0275fac }) } return t })(); function eo(t, r) { let e = t.url.toLowerCase(); if (!f(Ti) || t.method === "GET" || t.method === "HEAD" || e.startsWith("http://") || e.startsWith("https://")) return r(t); let n = f(xt).getToken(), i = f(Ys); return n != null && !t.headers.has(i) && (t = t.clone({ headers: t.headers.set(i, n) })), r(t) } var Ei = function (t) { return t[t.Interceptors = 0] = "Interceptors", t[t.LegacyInterceptors = 1] = "LegacyInterceptors", t[t.CustomXsrfConfiguration = 2] = "CustomXsrfConfiguration", t[t.NoXsrfProtection = 3] = "NoXsrfProtection", t[t.JsonpSupport = 4] = "JsonpSupport", t[t.RequestsMadeViaParent = 5] = "RequestsMadeViaParent", t[t.Fetch = 6] = "Fetch", t }(Ei || {}); function to(t, r) { return { \u0275kind: t, \u0275providers: r } } function $c(...t) { let r = [Ar, Si, Ri, { provide: Be, useExisting: Ri }, { provide: Pt, useFactory: () => f(zs, { optional: !0 }) ?? f(Si) }, { provide: Mr, useValue: eo, multi: !0 }, { provide: Ti, useValue: !0 }, { provide: xt, useClass: Qs }]; for (let e of t) r.push(...e.\u0275providers); return Le(r) } function Fc(t) { return to(Ei.Interceptors, t.map(r => ({ provide: Mr, useValue: r, multi: !0 }))) } var Or = class extends li { supportsDOMEvents = !0 }, Pr = class t extends Or { static makeCurrent() { ci(new t) } onAndCancel(r, e, n) { return r.addEventListener(e, n), () => { r.removeEventListener(e, n) } } dispatchEvent(r, e) { r.dispatchEvent(e) } remove(r) { r.remove() } createElement(r, e) { return e = e || this.getDefaultDocument(), e.createElement(r) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(r) { return r.nodeType === Node.ELEMENT_NODE } isShadowRoot(r) { return r instanceof DocumentFragment } getGlobalEventTarget(r, e) { return e === "window" ? window : e === "document" ? r : e === "body" ? r.body : null } getBaseHref(r) { let e = io(); return e == null ? null : so(e) } resetBaseElement() { Ge = null } getUserAgent() { return window.navigator.userAgent } getCookie(r) { return At(document.cookie, r) } }, Ge = null; function io() { return Ge = Ge || document.querySelector("base"), Ge ? Ge.getAttribute("href") : null } function so(t) { return new URL(t, document.baseURI).pathname } var oo = (() => { class t { build() { return new XMLHttpRequest } static \u0275fac = function (n) { return new (n || t) }; static \u0275prov = w({ token: t, factory: t.\u0275fac }) } return t })(), Nr = new E(""), Oi = (() => { class t { _zone; _plugins; _eventNameToPlugin = new Map; constructor(e, n) { this._zone = n, e.forEach(i => { i.manager = this }), this._plugins = e.slice().reverse() } addEventListener(e, n, i) { return this._findPluginFor(n).addEventListener(e, n, i) } getZone() { return this._zone } _findPluginFor(e) { let n = this._eventNameToPlugin.get(e); if (n) return n; if (n = this._plugins.find(s => s.supports(e)), !n) throw new C(5101, !1); return this._eventNameToPlugin.set(e, n), n } static \u0275fac = function (n) { return new (n || t)(v(Nr), v(q)) }; static \u0275prov = w({ token: t, factory: t.\u0275fac }) } return t })(), kt = class { _doc; constructor(r) { this._doc = r } manager }, Ut = "ng-app-id"; function Ci(t) { for (let r of t) r.remove() } function Ii(t, r) { let e = r.createElement("style"); return e.textContent = t, e } function ao(t, r, e, n) { let i = t.head?.querySelectorAll(`style[${Ut}="${r}"],link[${Ut}="${r}"]`); if (i) for (let s of i) s.removeAttribute(Ut), s instanceof HTMLLinkElement ? n.set(s.href.slice(s.href.lastIndexOf("/") + 1), { usage: 0, elements: [s] }) : s.textContent && e.set(s.textContent, { usage: 0, elements: [s] }) } function xr(t, r) { let e = r.createElement("link"); return e.setAttribute("rel", "stylesheet"), e.setAttribute("href", t), e } var Pi = (() => { class t { doc; appId; nonce; inline = new Map; external = new Map; hosts = new Set; isServer; constructor(e, n, i, s = {}) { this.doc = e, this.appId = n, this.nonce = i, this.isServer = Mt(s), ao(e, n, this.inline, this.external), this.hosts.add(e.head) } addStyles(e, n) { for (let i of e) this.addUsage(i, this.inline, Ii); n?.forEach(i => this.addUsage(i, this.external, xr)) } removeStyles(e, n) { for (let i of e) this.removeUsage(i, this.inline); n?.forEach(i => this.removeUsage(i, this.external)) } addUsage(e, n, i) { let s = n.get(e); s ? s.usage++ : n.set(e, { usage: 1, elements: [...this.hosts].map(o => this.addElement(o, i(e, this.doc))) }) } removeUsage(e, n) { let i = n.get(e); i && (i.usage--, i.usage <= 0 && (Ci(i.elements), n.delete(e))) } ngOnDestroy() { for (let [, { elements: e }] of [...this.inline, ...this.external]) Ci(e); this.hosts.clear() } addHost(e) { this.hosts.add(e); for (let [n, { elements: i }] of this.inline) i.push(this.addElement(e, Ii(n, this.doc))); for (let [n, { elements: i }] of this.external) i.push(this.addElement(e, xr(n, this.doc))) } removeHost(e) { this.hosts.delete(e) } addElement(e, n) { return this.nonce && n.setAttribute("nonce", this.nonce), this.isServer && n.setAttribute(Ut, this.appId), e.appendChild(n) } static \u0275fac = function (n) { return new (n || t)(v(x), v(gr), v(mr, 8), v(ue)) }; static \u0275prov = w({ token: t, factory: t.\u0275fac }) } return t })(), Dr = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/Math/MathML" }, kr = /%COMP%/g, Ni = "%COMP%", co = `_nghost-${Ni}`, lo = `_ngcontent-${Ni}`, uo = !0, ho = new E("", { providedIn: "root", factory: () => uo }); function fo(t) { return lo.replace(kr, t) } function po(t) { return co.replace(kr, t) } function xi(t, r) { return r.map(e => e.replace(kr, t)) } var Ai = (() => { class t { eventManager; sharedStylesHost; appId; removeStylesOnCompDestroy; doc; platformId; ngZone; nonce; rendererByCompId = new Map; defaultRenderer; platformIsServer; constructor(e, n, i, s, o, c, a, l = null) { this.eventManager = e, this.sharedStylesHost = n, this.appId = i, this.removeStylesOnCompDestroy = s, this.doc = o, this.platformId = c, this.ngZone = a, this.nonce = l, this.platformIsServer = Mt(c), this.defaultRenderer = new We(e, o, a, this.platformIsServer) } createRenderer(e, n) { if (!e || !n) return this.defaultRenderer; this.platformIsServer && n.encapsulation === _e.ShadowDom && (n = P(h({}, n), { encapsulation: _e.Emulated })); let i = this.getOrCreateRenderer(e, n); return i instanceof Lt ? i.applyToHost(e) : i instanceof He && i.applyStyles(), i } getOrCreateRenderer(e, n) { let i = this.rendererByCompId, s = i.get(n.id); if (!s) { let o = this.doc, c = this.ngZone, a = this.eventManager, l = this.sharedStylesHost, u = this.removeStylesOnCompDestroy, d = this.platformIsServer; switch (n.encapsulation) { case _e.Emulated: s = new Lt(a, l, n, this.appId, u, o, c, d); break; case _e.ShadowDom: return new Ur(a, l, e, n, o, c, this.nonce, d); default: s = new He(a, l, n, u, o, c, d); break }i.set(n.id, s) } return s } ngOnDestroy() { this.rendererByCompId.clear() } static \u0275fac = function (n) { return new (n || t)(v(Oi), v(Pi), v(gr), v(ho), v(x), v(ue), v(q), v(mr)) }; static \u0275prov = w({ token: t, factory: t.\u0275fac }) } return t })(), We = class { eventManager; doc; ngZone; platformIsServer; data = Object.create(null); throwOnSyntheticProps = !0; constructor(r, e, n, i) { this.eventManager = r, this.doc = e, this.ngZone = n, this.platformIsServer = i } destroy() { } destroyNode = null; createElement(r, e) { return e ? this.doc.createElementNS(Dr[e] || e, r) : this.doc.createElement(r) } createComment(r) { return this.doc.createComment(r) } createText(r) { return this.doc.createTextNode(r) } appendChild(r, e) { (Mi(r) ? r.content : r).appendChild(e) } insertBefore(r, e, n) { r && (Mi(r) ? r.content : r).insertBefore(e, n) } removeChild(r, e) { e.remove() } selectRootElement(r, e) { let n = typeof r == "string" ? this.doc.querySelector(r) : r; if (!n) throw new C(-5104, !1); return e || (n.textContent = ""), n } parentNode(r) { return r.parentNode } nextSibling(r) { return r.nextSibling } setAttribute(r, e, n, i) { if (i) { e = i + ":" + e; let s = Dr[i]; s ? r.setAttributeNS(s, e, n) : r.setAttribute(e, n) } else r.setAttribute(e, n) } removeAttribute(r, e, n) { if (n) { let i = Dr[n]; i ? r.removeAttributeNS(i, e) : r.removeAttribute(`${n}:${e}`) } else r.removeAttribute(e) } addClass(r, e) { r.classList.add(e) } removeClass(r, e) { r.classList.remove(e) } setStyle(r, e, n, i) { i & (je.DashCase | je.Important) ? r.style.setProperty(e, n, i & je.Important ? "important" : "") : r.style[e] = n } removeStyle(r, e, n) { n & je.DashCase ? r.style.removeProperty(e) : r.style[e] = "" } setProperty(r, e, n) { r != null && (r[e] = n) } setValue(r, e) { r.nodeValue = e } listen(r, e, n) { if (typeof r == "string" && (r = Rr().getGlobalEventTarget(this.doc, r), !r)) throw new Error(`Unsupported event target ${r} for event ${e}`); return this.eventManager.addEventListener(r, e, this.decoratePreventDefault(n)) } decoratePreventDefault(r) { return e => { if (e === "__ngUnwrap__") return r; (this.platformIsServer ? this.ngZone.runGuarded(() => r(e)) : r(e)) === !1 && e.preventDefault() } } }; function Mi(t) { return t.tagName === "TEMPLATE" && t.content !== void 0 } var Ur = class extends We { sharedStylesHost; hostEl; shadowRoot; constructor(r, e, n, i, s, o, c, a) { super(r, s, o, a), this.sharedStylesHost = e, this.hostEl = n, this.shadowRoot = n.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); let l = xi(i.id, i.styles); for (let d of l) { let m = document.createElement("style"); c && m.setAttribute("nonce", c), m.textContent = d, this.shadowRoot.appendChild(m) } let u = i.getExternalStyles?.(); if (u) for (let d of u) { let m = xr(d, s); c && m.setAttribute("nonce", c), this.shadowRoot.appendChild(m) } } nodeOrShadowRoot(r) { return r === this.hostEl ? this.shadowRoot : r } appendChild(r, e) { return super.appendChild(this.nodeOrShadowRoot(r), e) } insertBefore(r, e, n) { return super.insertBefore(this.nodeOrShadowRoot(r), e, n) } removeChild(r, e) { return super.removeChild(null, e) } parentNode(r) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(r))) } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } }, He = class extends We { sharedStylesHost; removeStylesOnCompDestroy; styles; styleUrls; constructor(r, e, n, i, s, o, c, a) { super(r, s, o, c), this.sharedStylesHost = e, this.removeStylesOnCompDestroy = i, this.styles = a ? xi(a, n.styles) : n.styles, this.styleUrls = n.getExternalStyles?.(a) } applyStyles() { this.sharedStylesHost.addStyles(this.styles, this.styleUrls) } destroy() { this.removeStylesOnCompDestroy && this.sharedStylesHost.removeStyles(this.styles, this.styleUrls) } }, Lt = class extends He { contentAttr; hostAttr; constructor(r, e, n, i, s, o, c, a) { let l = i + "-" + n.id; super(r, e, n, s, o, c, a, l), this.contentAttr = fo(l), this.hostAttr = po(l) } applyToHost(r) { this.applyStyles(), this.setAttribute(r, this.hostAttr, "") } createElement(r, e) { let n = super.createElement(r, e); return super.setAttribute(n, this.contentAttr, ""), n } }, go = (() => { class t extends kt { constructor(e) { super(e) } supports(e) { return !0 } addEventListener(e, n, i) { return e.addEventListener(n, i, !1), () => this.removeEventListener(e, n, i) } removeEventListener(e, n, i) { return e.removeEventListener(n, i) } static \u0275fac = function (n) { return new (n || t)(v(x)) }; static \u0275prov = w({ token: t, factory: t.\u0275fac }) } return t })(), Di = ["alt", "control", "meta", "shift"], mo = { "\b": "Backspace", "	": "Tab", "\x7F": "Delete", "\x1B": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, vo = { alt: t => t.altKey, control: t => t.ctrlKey, meta: t => t.metaKey, shift: t => t.shiftKey }, yo = (() => { class t extends kt { constructor(e) { super(e) } supports(e) { return t.parseEventName(e) != null } addEventListener(e, n, i) { let s = t.parseEventName(n), o = t.eventCallback(s.fullKey, i, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => Rr().onAndCancel(e, s.domEventName, o)) } static parseEventName(e) { let n = e.toLowerCase().split("."), i = n.shift(); if (n.length === 0 || !(i === "keydown" || i === "keyup")) return null; let s = t._normalizeKey(n.pop()), o = "", c = n.indexOf("code"); if (c > -1 && (n.splice(c, 1), o = "code."), Di.forEach(l => { let u = n.indexOf(l); u > -1 && (n.splice(u, 1), o += l + ".") }), o += s, n.length != 0 || s.length === 0) return null; let a = {}; return a.domEventName = i, a.fullKey = o, a } static matchEventFullKeyCode(e, n) { let i = mo[e.key] || e.key, s = ""; return n.indexOf("code.") > -1 && (i = e.code, s = "code."), i == null || !i ? !1 : (i = i.toLowerCase(), i === " " ? i = "space" : i === "." && (i = "dot"), Di.forEach(o => { if (o !== i) { let c = vo[o]; c(e) && (s += o + ".") } }), s += i, s === n) } static eventCallback(e, n, i) { return s => { t.matchEventFullKeyCode(s, e) && i.runGuarded(() => n(s)) } } static _normalizeKey(e) { return e === "esc" ? "escape" : e } static \u0275fac = function (n) { return new (n || t)(v(x)) }; static \u0275prov = w({ token: t, factory: t.\u0275fac }) } return t })(); function dl(t, r) { return oi(h({ rootComponent: t }, wo(r))) } function wo(t) { return { appProviders: [...Eo, ...t?.providers ?? []], platformProviders: To } } function Ro() { Pr.makeCurrent() } function So() { return new fr } function bo() { return kn(document), document } var To = [{ provide: ue, useValue: fi }, { provide: Ln, useValue: Ro, multi: !0 }, { provide: x, useFactory: bo, deps: [] }]; var Eo = [{ provide: Nn, useValue: "root" }, { provide: fr, useFactory: So, deps: [] }, { provide: Nr, useClass: go, multi: !0, deps: [x, q, ue] }, { provide: Nr, useClass: yo, multi: !0, deps: [x] }, Ai, Pi, Oi, { provide: Hn, useExisting: Ai }, { provide: Dt, useClass: oo, deps: [] }, []]; var Ui = (() => { class t { _doc; constructor(e) { this._doc = e } getTitle() { return this._doc.title } setTitle(e) { this._doc.title = e || "" } static \u0275fac = function (n) { return new (n || t)(v(x)) }; static \u0275prov = w({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); var Co = (() => { class t { static \u0275fac = function (n) { return new (n || t) }; static \u0275prov = w({ token: t, factory: function (n) { let i = null; return n ? i = new (n || t) : i = v(Io), i }, providedIn: "root" }) } return t })(), Io = (() => { class t extends Co { _doc; constructor(e) { super(), this._doc = e } sanitize(e, n) { if (n == null) return null; switch (e) { case de.NONE: return n; case de.HTML: return Re(n, "HTML") ? we(n) : qn(this._doc, String(n)).toString(); case de.STYLE: return Re(n, "Style") ? we(n) : n; case de.SCRIPT: if (Re(n, "Script")) return we(n); throw new C(5200, !1); case de.URL: return Re(n, "URL") ? we(n) : Vn(String(n)); case de.RESOURCE_URL: if (Re(n, "ResourceURL")) return we(n); throw new C(5201, !1); default: throw new C(5202, !1) } } bypassSecurityTrustHtml(e) { return jn(e) } bypassSecurityTrustStyle(e) { return $n(e) } bypassSecurityTrustScript(e) { return Fn(e) } bypassSecurityTrustUrl(e) { return zn(e) } bypassSecurityTrustResourceUrl(e) { return Bn(e) } static \u0275fac = function (n) { return new (n || t)(v(x)) }; static \u0275prov = w({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); var g = "primary", ct = Symbol("RouteTitle"), Fr = class { params; constructor(r) { this.params = r || {} } has(r) { return Object.prototype.hasOwnProperty.call(this.params, r) } get(r) { if (this.has(r)) { let e = this.params[r]; return Array.isArray(e) ? e[0] : e } return null } getAll(r) { if (this.has(r)) { let e = this.params[r]; return Array.isArray(e) ? e : [e] } return [] } get keys() { return Object.keys(this.params) } }; function Ie(t) { return new Fr(t) } function Mo(t, r, e) { let n = e.path.split("/"); if (n.length > t.length || e.pathMatch === "full" && (r.hasChildren() || n.length < t.length)) return null; let i = {}; for (let s = 0; s < n.length; s++) { let o = n[s], c = t[s]; if (o[0] === ":") i[o.substring(1)] = c; else if (o !== c.path) return null } return { consumed: t.slice(0, n.length), posParams: i } } function Do(t, r) { if (t.length !== r.length) return !1; for (let e = 0; e < t.length; ++e)if (!G(t[e], r[e])) return !1; return !0 } function G(t, r) { let e = t ? zr(t) : void 0, n = r ? zr(r) : void 0; if (!e || !n || e.length != n.length) return !1; let i; for (let s = 0; s < e.length; s++)if (i = e[s], !Wi(t[i], r[i])) return !1; return !0 } function zr(t) { return [...Object.keys(t), ...Object.getOwnPropertySymbols(t)] } function Wi(t, r) { if (Array.isArray(t) && Array.isArray(r)) { if (t.length !== r.length) return !1; let e = [...t].sort(), n = [...r].sort(); return e.every((i, s) => n[s] === i) } else return t === r } function Hi(t) { return t.length > 0 ? t[t.length - 1] : null } function ae(t) { return bn(t) ? t : Qn(t) ? O(Promise.resolve(t)) : p(t) } var Oo = { exact: Ji, subset: Zi }, Xi = { exact: Po, subset: No, ignored: () => !0 }; function ki(t, r, e) { return Oo[e.paths](t.root, r.root, e.matrixParams) && Xi[e.queryParams](t.queryParams, r.queryParams) && !(e.fragment === "exact" && t.fragment !== r.fragment) } function Po(t, r) { return G(t, r) } function Ji(t, r, e) { if (!fe(t.segments, r.segments) || !$t(t.segments, r.segments, e) || t.numberOfChildren !== r.numberOfChildren) return !1; for (let n in r.children) if (!t.children[n] || !Ji(t.children[n], r.children[n], e)) return !1; return !0 } function No(t, r) { return Object.keys(r).length <= Object.keys(t).length && Object.keys(r).every(e => Wi(t[e], r[e])) } function Zi(t, r, e) { return Ki(t, r, r.segments, e) } function Ki(t, r, e, n) { if (t.segments.length > e.length) { let i = t.segments.slice(0, e.length); return !(!fe(i, e) || r.hasChildren() || !$t(i, e, n)) } else if (t.segments.length === e.length) { if (!fe(t.segments, e) || !$t(t.segments, e, n)) return !1; for (let i in r.children) if (!t.children[i] || !Zi(t.children[i], r.children[i], n)) return !1; return !0 } else { let i = e.slice(0, t.segments.length), s = e.slice(t.segments.length); return !fe(t.segments, i) || !$t(t.segments, i, n) || !t.children[g] ? !1 : Ki(t.children[g], r, s, n) } } function $t(t, r, e) { return r.every((n, i) => Xi[e](t[i].parameters, n.parameters)) } var Z = class { root; queryParams; fragment; _queryParamMap; constructor(r = new T([], {}), e = {}, n = null) { this.root = r, this.queryParams = e, this.fragment = n } get queryParamMap() { return this._queryParamMap ??= Ie(this.queryParams), this._queryParamMap } toString() { return ko.serialize(this) } }, T = class { segments; children; parent = null; constructor(r, e) { this.segments = r, this.children = e, Object.values(e).forEach(n => n.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return Ft(this) } }, he = class { path; parameters; _parameterMap; constructor(r, e) { this.path = r, this.parameters = e } get parameterMap() { return this._parameterMap ??= Ie(this.parameters), this._parameterMap } toString() { return Qi(this) } }; function xo(t, r) { return fe(t, r) && t.every((e, n) => G(e.parameters, r[n].parameters)) } function fe(t, r) { return t.length !== r.length ? !1 : t.every((e, n) => e.path === r[n].path) } function Uo(t, r) { let e = []; return Object.entries(t.children).forEach(([n, i]) => { n === g && (e = e.concat(r(i, n))) }), Object.entries(t.children).forEach(([n, i]) => { n !== g && (e = e.concat(r(i, n))) }), e } var lt = (() => { class t { static \u0275fac = function (n) { return new (n || t) }; static \u0275prov = w({ token: t, factory: () => new Ae, providedIn: "root" }) } return t })(), Ae = class { parse(r) { let e = new Vr(r); return new Z(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment()) } serialize(r) { let e = `/${Xe(r.root, !0)}`, n = jo(r.queryParams), i = typeof r.fragment == "string" ? `#${Lo(r.fragment)}` : ""; return `${e}${n}${i}` } }, ko = new Ae; function Ft(t) { return t.segments.map(r => Qi(r)).join("/") } function Xe(t, r) { if (!t.hasChildren()) return Ft(t); if (r) { let e = t.children[g] ? Xe(t.children[g], !1) : "", n = []; return Object.entries(t.children).forEach(([i, s]) => { i !== g && n.push(`${i}:${Xe(s, !1)}`) }), n.length > 0 ? `${e}(${n.join("//")})` : e } else { let e = Uo(t, (n, i) => i === g ? [Xe(t.children[g], !1)] : [`${i}:${Xe(n, !1)}`]); return Object.keys(t.children).length === 1 && t.children[g] != null ? `${Ft(t)}/${e[0]}` : `${Ft(t)}/(${e.join("//")})` } } function Yi(t) { return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function _t(t) { return Yi(t).replace(/%3B/gi, ";") } function Lo(t) { return encodeURI(t) } function Br(t) { return Yi(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function zt(t) { return decodeURIComponent(t) } function Li(t) { return zt(t.replace(/\+/g, "%20")) } function Qi(t) { return `${Br(t.path)}${_o(t.parameters)}` } function _o(t) { return Object.entries(t).map(([r, e]) => `;${Br(r)}=${Br(e)}`).join("") } function jo(t) { let r = Object.entries(t).map(([e, n]) => Array.isArray(n) ? n.map(i => `${_t(e)}=${_t(i)}`).join("&") : `${_t(e)}=${_t(n)}`).filter(e => e); return r.length ? `?${r.join("&")}` : "" } var $o = /^[^\/()?;#]+/; function Lr(t) { let r = t.match($o); return r ? r[0] : "" } var Fo = /^[^\/()?;=#]+/; function zo(t) { let r = t.match(Fo); return r ? r[0] : "" } var Bo = /^[^=?&#]+/; function Vo(t) { let r = t.match(Bo); return r ? r[0] : "" } var qo = /^[^&#]+/; function Go(t) { let r = t.match(qo); return r ? r[0] : "" } var Vr = class { url; remaining; constructor(r) { this.url = r, this.remaining = r } parseRootSegment() { return this.consumeOptional("/"), this.remaining === "" || this.peekStartsWith("?") || this.peekStartsWith("#") ? new T([], {}) : new T([], this.parseChildren()) } parseQueryParams() { let r = {}; if (this.consumeOptional("?")) do this.parseQueryParam(r); while (this.consumeOptional("&")); return r } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if (this.remaining === "") return {}; this.consumeOptional("/"); let r = []; for (this.peekStartsWith("(") || r.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), r.push(this.parseSegment()); let e = {}; this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0)); let n = {}; return this.peekStartsWith("(") && (n = this.parseParens(!1)), (r.length > 0 || Object.keys(e).length > 0) && (n[g] = new T(r, e)), n } parseSegment() { let r = Lr(this.remaining); if (r === "" && this.peekStartsWith(";")) throw new C(4009, !1); return this.capture(r), new he(zt(r), this.parseMatrixParams()) } parseMatrixParams() { let r = {}; for (; this.consumeOptional(";");)this.parseParam(r); return r } parseParam(r) { let e = zo(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { let i = Lr(this.remaining); i && (n = i, this.capture(n)) } r[zt(e)] = zt(n) } parseQueryParam(r) { let e = Vo(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { let o = Go(this.remaining); o && (n = o, this.capture(n)) } let i = Li(e), s = Li(n); if (r.hasOwnProperty(i)) { let o = r[i]; Array.isArray(o) || (o = [o], r[i] = o), o.push(s) } else r[i] = s } parseParens(r) { let e = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { let n = Lr(this.remaining), i = this.remaining[n.length]; if (i !== "/" && i !== ")" && i !== ";") throw new C(4010, !1); let s; n.indexOf(":") > -1 ? (s = n.slice(0, n.indexOf(":")), this.capture(s), this.capture(":")) : r && (s = g); let o = this.parseChildren(); e[s] = Object.keys(o).length === 1 ? o[g] : new T([], o), this.consumeOptional("//") } return e } peekStartsWith(r) { return this.remaining.startsWith(r) } consumeOptional(r) { return this.peekStartsWith(r) ? (this.remaining = this.remaining.substring(r.length), !0) : !1 } capture(r) { if (!this.consumeOptional(r)) throw new C(4011, !1) } }; function es(t) { return t.segments.length > 0 ? new T([], { [g]: t }) : t } function ts(t) { let r = {}; for (let [n, i] of Object.entries(t.children)) { let s = ts(i); if (n === g && s.segments.length === 0 && s.hasChildren()) for (let [o, c] of Object.entries(s.children)) r[o] = c; else (s.segments.length > 0 || s.hasChildren()) && (r[n] = s) } let e = new T(t.segments, r); return Wo(e) } function Wo(t) { if (t.numberOfChildren === 1 && t.children[g]) { let r = t.children[g]; return new T(t.segments.concat(r.segments), r.children) } return t } function pe(t) { return t instanceof Z } function Ho(t, r, e = null, n = null) { let i = rs(t); return ns(i, r, e, n) } function rs(t) { let r; function e(s) { let o = {}; for (let a of s.children) { let l = e(a); o[a.outlet] = l } let c = new T(s.url, o); return s === t && (r = c), c } let n = e(t.root), i = es(n); return r ?? i } function ns(t, r, e, n) { let i = t; for (; i.parent;)i = i.parent; if (r.length === 0) return _r(i, i, i, e, n); let s = Xo(r); if (s.toRoot()) return _r(i, i, new T([], {}), e, n); let o = Jo(s, i, t), c = o.processChildren ? Ke(o.segmentGroup, o.index, s.commands) : ss(o.segmentGroup, o.index, s.commands); return _r(i, o.segmentGroup, c, e, n) } function Bt(t) { return typeof t == "object" && t != null && !t.outlets && !t.segmentPath } function et(t) { return typeof t == "object" && t != null && t.outlets } function _r(t, r, e, n, i) { let s = {}; n && Object.entries(n).forEach(([a, l]) => { s[a] = Array.isArray(l) ? l.map(u => `${u}`) : `${l}` }); let o; t === r ? o = e : o = is(t, r, e); let c = es(ts(o)); return new Z(c, s, i) } function is(t, r, e) { let n = {}; return Object.entries(t.children).forEach(([i, s]) => { s === r ? n[i] = e : n[i] = is(s, r, e) }), new T(t.segments, n) } var Vt = class { isAbsolute; numberOfDoubleDots; commands; constructor(r, e, n) { if (this.isAbsolute = r, this.numberOfDoubleDots = e, this.commands = n, r && n.length > 0 && Bt(n[0])) throw new C(4003, !1); let i = n.find(et); if (i && i !== Hi(n)) throw new C(4004, !1) } toRoot() { return this.isAbsolute && this.commands.length === 1 && this.commands[0] == "/" } }; function Xo(t) { if (typeof t[0] == "string" && t.length === 1 && t[0] === "/") return new Vt(!0, 0, t); let r = 0, e = !1, n = t.reduce((i, s, o) => { if (typeof s == "object" && s != null) { if (s.outlets) { let c = {}; return Object.entries(s.outlets).forEach(([a, l]) => { c[a] = typeof l == "string" ? l.split("/") : l }), [...i, { outlets: c }] } if (s.segmentPath) return [...i, s.segmentPath] } return typeof s != "string" ? [...i, s] : o === 0 ? (s.split("/").forEach((c, a) => { a == 0 && c === "." || (a == 0 && c === "" ? e = !0 : c === ".." ? r++ : c != "" && i.push(c)) }), i) : [...i, s] }, []); return new Vt(e, r, n) } var Te = class { segmentGroup; processChildren; index; constructor(r, e, n) { this.segmentGroup = r, this.processChildren = e, this.index = n } }; function Jo(t, r, e) { if (t.isAbsolute) return new Te(r, !0, 0); if (!e) return new Te(r, !1, NaN); if (e.parent === null) return new Te(e, !0, 0); let n = Bt(t.commands[0]) ? 0 : 1, i = e.segments.length - 1 + n; return Zo(e, i, t.numberOfDoubleDots) } function Zo(t, r, e) { let n = t, i = r, s = e; for (; s > i;) { if (s -= i, n = n.parent, !n) throw new C(4005, !1); i = n.segments.length } return new Te(n, !1, i - s) } function Ko(t) { return et(t[0]) ? t[0].outlets : { [g]: t } } function ss(t, r, e) { if (t ??= new T([], {}), t.segments.length === 0 && t.hasChildren()) return Ke(t, r, e); let n = Yo(t, r, e), i = e.slice(n.commandIndex); if (n.match && n.pathIndex < t.segments.length) { let s = new T(t.segments.slice(0, n.pathIndex), {}); return s.children[g] = new T(t.segments.slice(n.pathIndex), t.children), Ke(s, 0, i) } else return n.match && i.length === 0 ? new T(t.segments, {}) : n.match && !t.hasChildren() ? qr(t, r, e) : n.match ? Ke(t, 0, i) : qr(t, r, e) } function Ke(t, r, e) { if (e.length === 0) return new T(t.segments, {}); { let n = Ko(e), i = {}; if (Object.keys(n).some(s => s !== g) && t.children[g] && t.numberOfChildren === 1 && t.children[g].segments.length === 0) { let s = Ke(t.children[g], r, e); return new T(t.segments, s.children) } return Object.entries(n).forEach(([s, o]) => { typeof o == "string" && (o = [o]), o !== null && (i[s] = ss(t.children[s], r, o)) }), Object.entries(t.children).forEach(([s, o]) => { n[s] === void 0 && (i[s] = o) }), new T(t.segments, i) } } function Yo(t, r, e) { let n = 0, i = r, s = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; i < t.segments.length;) { if (n >= e.length) return s; let o = t.segments[i], c = e[n]; if (et(c)) break; let a = `${c}`, l = n < e.length - 1 ? e[n + 1] : null; if (i > 0 && a === void 0) break; if (a && l && typeof l == "object" && l.outlets === void 0) { if (!ji(a, l, o)) return s; n += 2 } else { if (!ji(a, {}, o)) return s; n++ } i++ } return { match: !0, pathIndex: i, commandIndex: n } } function qr(t, r, e) { let n = t.segments.slice(0, r), i = 0; for (; i < e.length;) { let s = e[i]; if (et(s)) { let a = Qo(s.outlets); return new T(n, a) } if (i === 0 && Bt(e[0])) { let a = t.segments[r]; n.push(new he(a.path, _i(e[0]))), i++; continue } let o = et(s) ? s.outlets[g] : `${s}`, c = i < e.length - 1 ? e[i + 1] : null; o && c && Bt(c) ? (n.push(new he(o, _i(c))), i += 2) : (n.push(new he(o, {})), i++) } return new T(n, {}) } function Qo(t) { let r = {}; return Object.entries(t).forEach(([e, n]) => { typeof n == "string" && (n = [n]), n !== null && (r[e] = qr(new T([], {}), 0, n)) }), r } function _i(t) { let r = {}; return Object.entries(t).forEach(([e, n]) => r[e] = `${n}`), r } function ji(t, r, e) { return t == e.path && G(r, e.parameters) } var Ye = "imperative", D = function (t) { return t[t.NavigationStart = 0] = "NavigationStart", t[t.NavigationEnd = 1] = "NavigationEnd", t[t.NavigationCancel = 2] = "NavigationCancel", t[t.NavigationError = 3] = "NavigationError", t[t.RoutesRecognized = 4] = "RoutesRecognized", t[t.ResolveStart = 5] = "ResolveStart", t[t.ResolveEnd = 6] = "ResolveEnd", t[t.GuardsCheckStart = 7] = "GuardsCheckStart", t[t.GuardsCheckEnd = 8] = "GuardsCheckEnd", t[t.RouteConfigLoadStart = 9] = "RouteConfigLoadStart", t[t.RouteConfigLoadEnd = 10] = "RouteConfigLoadEnd", t[t.ChildActivationStart = 11] = "ChildActivationStart", t[t.ChildActivationEnd = 12] = "ChildActivationEnd", t[t.ActivationStart = 13] = "ActivationStart", t[t.ActivationEnd = 14] = "ActivationEnd", t[t.Scroll = 15] = "Scroll", t[t.NavigationSkipped = 16] = "NavigationSkipped", t }(D || {}), F = class { id; url; constructor(r, e) { this.id = r, this.url = e } }, Me = class extends F { type = D.NavigationStart; navigationTrigger; restoredState; constructor(r, e, n = "imperative", i = null) { super(r, e), this.navigationTrigger = n, this.restoredState = i } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } }, V = class extends F { urlAfterRedirects; type = D.NavigationEnd; constructor(r, e, n) { super(r, e), this.urlAfterRedirects = n } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } }, _ = function (t) { return t[t.Redirect = 0] = "Redirect", t[t.SupersededByNewNavigation = 1] = "SupersededByNewNavigation", t[t.NoDataFromResolver = 2] = "NoDataFromResolver", t[t.GuardRejected = 3] = "GuardRejected", t }(_ || {}), qt = function (t) { return t[t.IgnoredSameUrlNavigation = 0] = "IgnoredSameUrlNavigation", t[t.IgnoredByUrlHandlingStrategy = 1] = "IgnoredByUrlHandlingStrategy", t }(qt || {}), J = class extends F { reason; code; type = D.NavigationCancel; constructor(r, e, n, i) { super(r, e), this.reason = n, this.code = i } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } }, se = class extends F { reason; code; type = D.NavigationSkipped; constructor(r, e, n, i) { super(r, e), this.reason = n, this.code = i } }, tt = class extends F { error; target; type = D.NavigationError; constructor(r, e, n, i) { super(r, e), this.error = n, this.target = i } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } }, Gt = class extends F { urlAfterRedirects; state; type = D.RoutesRecognized; constructor(r, e, n, i) { super(r, e), this.urlAfterRedirects = n, this.state = i } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } }, Gr = class extends F { urlAfterRedirects; state; type = D.GuardsCheckStart; constructor(r, e, n, i) { super(r, e), this.urlAfterRedirects = n, this.state = i } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } }, Wr = class extends F { urlAfterRedirects; state; shouldActivate; type = D.GuardsCheckEnd; constructor(r, e, n, i, s) { super(r, e), this.urlAfterRedirects = n, this.state = i, this.shouldActivate = s } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } }, Hr = class extends F { urlAfterRedirects; state; type = D.ResolveStart; constructor(r, e, n, i) { super(r, e), this.urlAfterRedirects = n, this.state = i } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } }, Xr = class extends F { urlAfterRedirects; state; type = D.ResolveEnd; constructor(r, e, n, i) { super(r, e), this.urlAfterRedirects = n, this.state = i } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } }, Jr = class { route; type = D.RouteConfigLoadStart; constructor(r) { this.route = r } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } }, Zr = class { route; type = D.RouteConfigLoadEnd; constructor(r) { this.route = r } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } }, Kr = class { snapshot; type = D.ChildActivationStart; constructor(r) { this.snapshot = r } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } }, Yr = class { snapshot; type = D.ChildActivationEnd; constructor(r) { this.snapshot = r } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } }, Qr = class { snapshot; type = D.ActivationStart; constructor(r) { this.snapshot = r } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } }, en = class { snapshot; type = D.ActivationEnd; constructor(r) { this.snapshot = r } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } }, Wt = class { routerEvent; position; anchor; type = D.Scroll; constructor(r, e, n) { this.routerEvent = r, this.position = e, this.anchor = n } toString() { let r = this.position ? `${this.position[0]}, ${this.position[1]}` : null; return `Scroll(anchor: '${this.anchor}', position: '${r}')` } }, rt = class { }, De = class { url; navigationBehaviorOptions; constructor(r, e) { this.url = r, this.navigationBehaviorOptions = e } }; function ea(t, r) { return t.providers && !t._injector && (t._injector = yr(t.providers, r, `Route: ${t.path}`)), t._injector ?? r } function B(t) { return t.outlet || g } function ta(t, r) { let e = t.filter(n => B(n) === r); return e.push(...t.filter(n => B(n) !== r)), e } function ut(t) { if (!t) return null; if (t.routeConfig?._injector) return t.routeConfig._injector; for (let r = t.parent; r; r = r.parent) { let e = r.routeConfig; if (e?._loadedInjector) return e._loadedInjector; if (e?._injector) return e._injector } return null } var tn = class { rootInjector; outlet = null; route = null; children; attachRef = null; get injector() { return ut(this.route?.snapshot) ?? this.rootInjector } constructor(r) { this.rootInjector = r, this.children = new dt(this.rootInjector) } }, dt = (() => { class t { rootInjector; contexts = new Map; constructor(e) { this.rootInjector = e } onChildOutletCreated(e, n) { let i = this.getOrCreateContext(e); i.outlet = n, this.contexts.set(e, i) } onChildOutletDestroyed(e) { let n = this.getContext(e); n && (n.outlet = null, n.attachRef = null) } onOutletDeactivated() { let e = this.contexts; return this.contexts = new Map, e } onOutletReAttached(e) { this.contexts = e } getOrCreateContext(e) { let n = this.getContext(e); return n || (n = new tn(this.rootInjector), this.contexts.set(e, n)), n } getContext(e) { return this.contexts.get(e) || null } static \u0275fac = function (n) { return new (n || t)(v(le)) }; static \u0275prov = w({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), Ht = class { _root; constructor(r) { this._root = r } get root() { return this._root.value } parent(r) { let e = this.pathFromRoot(r); return e.length > 1 ? e[e.length - 2] : null } children(r) { let e = rn(r, this._root); return e ? e.children.map(n => n.value) : [] } firstChild(r) { let e = rn(r, this._root); return e && e.children.length > 0 ? e.children[0].value : null } siblings(r) { let e = nn(r, this._root); return e.length < 2 ? [] : e[e.length - 2].children.map(i => i.value).filter(i => i !== r) } pathFromRoot(r) { return nn(r, this._root).map(e => e.value) } }; function rn(t, r) { if (t === r.value) return r; for (let e of r.children) { let n = rn(t, e); if (n) return n } return null } function nn(t, r) { if (t === r.value) return [r]; for (let e of r.children) { let n = nn(t, e); if (n.length) return n.unshift(r), n } return [] } var L = class { value; children; constructor(r, e) { this.value = r, this.children = e } toString() { return `TreeNode(${this.value})` } }; function be(t) { let r = {}; return t && t.children.forEach(e => r[e.value.outlet] = e), r } var Xt = class extends Ht { snapshot; constructor(r, e) { super(r), this.snapshot = e, fn(this, r) } toString() { return this.snapshot.toString() } }; function os(t) { let r = ra(t), e = new j([new he("", {})]), n = new j({}), i = new j({}), s = new j({}), o = new j(""), c = new oe(e, n, s, o, i, g, t, r.root); return c.snapshot = r.root, new Xt(new L(c, []), r) } function ra(t) { let r = {}, e = {}, n = {}, i = "", s = new Ee([], r, n, i, e, g, t, null, {}); return new Zt("", new L(s, [])) } var oe = class { urlSubject; paramsSubject; queryParamsSubject; fragmentSubject; dataSubject; outlet; component; snapshot; _futureSnapshot; _routerState; _paramMap; _queryParamMap; title; url; params; queryParams; fragment; data; constructor(r, e, n, i, s, o, c, a) { this.urlSubject = r, this.paramsSubject = e, this.queryParamsSubject = n, this.fragmentSubject = i, this.dataSubject = s, this.outlet = o, this.component = c, this._futureSnapshot = a, this.title = this.dataSubject?.pipe(S(l => l[ct])) ?? p(void 0), this.url = r, this.params = e, this.queryParams = n, this.fragment = i, this.data = s } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap ??= this.params.pipe(S(r => Ie(r))), this._paramMap } get queryParamMap() { return this._queryParamMap ??= this.queryParams.pipe(S(r => Ie(r))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } }; function Jt(t, r, e = "emptyOnly") { let n, { routeConfig: i } = t; return r !== null && (e === "always" || i?.path === "" || !r.component && !r.routeConfig?.loadComponent) ? n = { params: h(h({}, r.params), t.params), data: h(h({}, r.data), t.data), resolve: h(h(h(h({}, t.data), r.data), i?.data), t._resolvedData) } : n = { params: h({}, t.params), data: h({}, t.data), resolve: h(h({}, t.data), t._resolvedData ?? {}) }, i && cs(i) && (n.resolve[ct] = i.title), n } var Ee = class { url; params; queryParams; fragment; data; outlet; component; routeConfig; _resolve; _resolvedData; _routerState; _paramMap; _queryParamMap; get title() { return this.data?.[ct] } constructor(r, e, n, i, s, o, c, a, l) { this.url = r, this.params = e, this.queryParams = n, this.fragment = i, this.data = s, this.outlet = o, this.component = c, this.routeConfig = a, this._resolve = l } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap ??= Ie(this.params), this._paramMap } get queryParamMap() { return this._queryParamMap ??= Ie(this.queryParams), this._queryParamMap } toString() { let r = this.url.map(n => n.toString()).join("/"), e = this.routeConfig ? this.routeConfig.path : ""; return `Route(url:'${r}', path:'${e}')` } }, Zt = class extends Ht { url; constructor(r, e) { super(e), this.url = r, fn(this, e) } toString() { return as(this._root) } }; function fn(t, r) { r.value._routerState = t, r.children.forEach(e => fn(t, e)) } function as(t) { let r = t.children.length > 0 ? ` { ${t.children.map(as).join(", ")} } ` : ""; return `${t.value}${r}` } function jr(t) { if (t.snapshot) { let r = t.snapshot, e = t._futureSnapshot; t.snapshot = e, G(r.queryParams, e.queryParams) || t.queryParamsSubject.next(e.queryParams), r.fragment !== e.fragment && t.fragmentSubject.next(e.fragment), G(r.params, e.params) || t.paramsSubject.next(e.params), Do(r.url, e.url) || t.urlSubject.next(e.url), G(r.data, e.data) || t.dataSubject.next(e.data) } else t.snapshot = t._futureSnapshot, t.dataSubject.next(t._futureSnapshot.data) } function sn(t, r) { let e = G(t.params, r.params) && xo(t.url, r.url), n = !t.parent != !r.parent; return e && !n && (!t.parent || sn(t.parent, r.parent)) } function cs(t) { return typeof t.title == "string" || t.title === null } var na = new E(""), ia = (() => { class t { activated = null; get activatedComponentRef() { return this.activated } _activatedRoute = null; name = g; activateEvents = new ye; deactivateEvents = new ye; attachEvents = new ye; detachEvents = new ye; routerOutletData = Un(void 0); parentContexts = f(dt); location = f(Xn); changeDetector = f(Ct); inputBinder = f(er, { optional: !0 }); supportsBindingToComponentInputs = !0; ngOnChanges(e) { if (e.name) { let { firstChange: n, previousValue: i } = e.name; if (n) return; this.isTrackedInParentContexts(i) && (this.deactivate(), this.parentContexts.onChildOutletDestroyed(i)), this.initializeOutletWithName() } } ngOnDestroy() { this.isTrackedInParentContexts(this.name) && this.parentContexts.onChildOutletDestroyed(this.name), this.inputBinder?.unsubscribeFromRouteData(this) } isTrackedInParentContexts(e) { return this.parentContexts.getContext(e)?.outlet === this } ngOnInit() { this.initializeOutletWithName() } initializeOutletWithName() { if (this.parentContexts.onChildOutletCreated(this.name, this), this.activated) return; let e = this.parentContexts.getContext(this.name); e?.route && (e.attachRef ? this.attach(e.attachRef, e.route) : this.activateWith(e.route, e.injector)) } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new C(4012, !1); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new C(4012, !1); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new C(4012, !1); this.location.detach(); let e = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(e.instance), e } attach(e, n) { this.activated = e, this._activatedRoute = n, this.location.insert(e.hostView), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.attachEvents.emit(e.instance) } deactivate() { if (this.activated) { let e = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(e) } } activateWith(e, n) { if (this.isActivated) throw new C(4013, !1); this._activatedRoute = e; let i = this.location, o = e.snapshot.component, c = this.parentContexts.getOrCreateContext(this.name).children, a = new on(e, c, i.injector, this.routerOutletData); this.activated = i.createComponent(o, { index: i.length, injector: a, environmentInjector: n }), this.changeDetector.markForCheck(), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.activateEvents.emit(this.activated.instance) } static \u0275fac = function (n) { return new (n || t) }; static \u0275dir = Rt({ type: t, selectors: [["router-outlet"]], inputs: { name: "name", routerOutletData: [1, "routerOutletData"] }, outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"], features: [vt] }) } return t })(), on = class t { route; childContexts; parent; outletData; __ngOutletInjector(r) { return new t(this.route, this.childContexts, r, this.outletData) } constructor(r, e, n, i) { this.route = r, this.childContexts = e, this.parent = n, this.outletData = i } get(r, e) { return r === oe ? this.route : r === dt ? this.childContexts : r === na ? this.outletData : this.parent.get(r, e) } }, er = new E(""), $i = (() => { class t { outletDataSubscriptions = new Map; bindActivatedRouteToOutletComponent(e) { this.unsubscribeFromRouteData(e), this.subscribeToRouteData(e) } unsubscribeFromRouteData(e) { this.outletDataSubscriptions.get(e)?.unsubscribe(), this.outletDataSubscriptions.delete(e) } subscribeToRouteData(e) { let { activatedRoute: n } = e, i = gt([n.queryParams, n.params, n.data]).pipe(k(([s, o, c], a) => (c = h(h(h({}, s), o), c), a === 0 ? p(c) : Promise.resolve(c)))).subscribe(s => { if (!e.isActivated || !e.activatedComponentRef || e.activatedRoute !== n || n.component === null) { this.unsubscribeFromRouteData(e); return } let o = ai(n.component); if (!o) { this.unsubscribeFromRouteData(e); return } for (let { templateName: c } of o.inputs) e.activatedComponentRef.setInput(c, s[c]) }); this.outletDataSubscriptions.set(e, i) } static \u0275fac = function (n) { return new (n || t) }; static \u0275prov = w({ token: t, factory: t.\u0275fac }) } return t })(); function sa(t, r, e) { let n = nt(t, r._root, e ? e._root : void 0); return new Xt(n, r) } function nt(t, r, e) { if (e && t.shouldReuseRoute(r.value, e.value.snapshot)) { let n = e.value; n._futureSnapshot = r.value; let i = oa(t, r, e); return new L(n, i) } else { if (t.shouldAttach(r.value)) { let s = t.retrieve(r.value); if (s !== null) { let o = s.route; return o.value._futureSnapshot = r.value, o.children = r.children.map(c => nt(t, c)), o } } let n = aa(r.value), i = r.children.map(s => nt(t, s)); return new L(n, i) } } function oa(t, r, e) { return r.children.map(n => { for (let i of e.children) if (t.shouldReuseRoute(n.value, i.value.snapshot)) return nt(t, n, i); return nt(t, n) }) } function aa(t) { return new oe(new j(t.url), new j(t.params), new j(t.queryParams), new j(t.fragment), new j(t.data), t.outlet, t.component, t) } var it = class { redirectTo; navigationBehaviorOptions; constructor(r, e) { this.redirectTo = r, this.navigationBehaviorOptions = e } }, ls = "ngNavigationCancelingError"; function Kt(t, r) { let { redirectTo: e, navigationBehaviorOptions: n } = pe(r) ? { redirectTo: r, navigationBehaviorOptions: void 0 } : r, i = us(!1, _.Redirect); return i.url = e, i.navigationBehaviorOptions = n, i } function us(t, r) { let e = new Error(`NavigationCancelingError: ${t || ""}`); return e[ls] = !0, e.cancellationCode = r, e } function ca(t) { return ds(t) && pe(t.url) } function ds(t) { return !!t && t[ls] } var la = (t, r, e, n) => S(i => (new an(r, i.targetRouterState, i.currentRouterState, e, n).activate(t), i)), an = class { routeReuseStrategy; futureState; currState; forwardEvent; inputBindingEnabled; constructor(r, e, n, i, s) { this.routeReuseStrategy = r, this.futureState = e, this.currState = n, this.forwardEvent = i, this.inputBindingEnabled = s } activate(r) { let e = this.futureState._root, n = this.currState ? this.currState._root : null; this.deactivateChildRoutes(e, n, r), jr(this.futureState.root), this.activateChildRoutes(e, n, r) } deactivateChildRoutes(r, e, n) { let i = be(e); r.children.forEach(s => { let o = s.value.outlet; this.deactivateRoutes(s, i[o], n), delete i[o] }), Object.values(i).forEach(s => { this.deactivateRouteAndItsChildren(s, n) }) } deactivateRoutes(r, e, n) { let i = r.value, s = e ? e.value : null; if (i === s) if (i.component) { let o = n.getContext(i.outlet); o && this.deactivateChildRoutes(r, e, o.children) } else this.deactivateChildRoutes(r, e, n); else s && this.deactivateRouteAndItsChildren(e, n) } deactivateRouteAndItsChildren(r, e) { r.value.component && this.routeReuseStrategy.shouldDetach(r.value.snapshot) ? this.detachAndStoreRouteSubtree(r, e) : this.deactivateRouteAndOutlet(r, e) } detachAndStoreRouteSubtree(r, e) { let n = e.getContext(r.value.outlet), i = n && r.value.component ? n.children : e, s = be(r); for (let o of Object.values(s)) this.deactivateRouteAndItsChildren(o, i); if (n && n.outlet) { let o = n.outlet.detach(), c = n.children.onOutletDeactivated(); this.routeReuseStrategy.store(r.value.snapshot, { componentRef: o, route: r, contexts: c }) } } deactivateRouteAndOutlet(r, e) { let n = e.getContext(r.value.outlet), i = n && r.value.component ? n.children : e, s = be(r); for (let o of Object.values(s)) this.deactivateRouteAndItsChildren(o, i); n && (n.outlet && (n.outlet.deactivate(), n.children.onOutletDeactivated()), n.attachRef = null, n.route = null) } activateChildRoutes(r, e, n) { let i = be(e); r.children.forEach(s => { this.activateRoutes(s, i[s.value.outlet], n), this.forwardEvent(new en(s.value.snapshot)) }), r.children.length && this.forwardEvent(new Yr(r.value.snapshot)) } activateRoutes(r, e, n) { let i = r.value, s = e ? e.value : null; if (jr(i), i === s) if (i.component) { let o = n.getOrCreateContext(i.outlet); this.activateChildRoutes(r, e, o.children) } else this.activateChildRoutes(r, e, n); else if (i.component) { let o = n.getOrCreateContext(i.outlet); if (this.routeReuseStrategy.shouldAttach(i.snapshot)) { let c = this.routeReuseStrategy.retrieve(i.snapshot); this.routeReuseStrategy.store(i.snapshot, null), o.children.onOutletReAttached(c.contexts), o.attachRef = c.componentRef, o.route = c.route.value, o.outlet && o.outlet.attach(c.componentRef, c.route.value), jr(c.route.value), this.activateChildRoutes(r, null, o.children) } else o.attachRef = null, o.route = i, o.outlet && o.outlet.activateWith(i, o.injector), this.activateChildRoutes(r, null, o.children) } else this.activateChildRoutes(r, null, n) } }, Yt = class { path; route; constructor(r) { this.path = r, this.route = this.path[this.path.length - 1] } }, Ce = class { component; route; constructor(r, e) { this.component = r, this.route = e } }; function ua(t, r, e) { let n = t._root, i = r ? r._root : null; return Je(n, i, e, [n.value]) } function da(t) { let r = t.routeConfig ? t.routeConfig.canActivateChild : null; return !r || r.length === 0 ? null : { node: t, guards: r } } function Pe(t, r) { let e = Symbol(), n = r.get(t, e); return n === e ? typeof t == "function" && !On(t) ? t : r.get(t) : n } function Je(t, r, e, n, i = { canDeactivateChecks: [], canActivateChecks: [] }) { let s = be(r); return t.children.forEach(o => { ha(o, s[o.value.outlet], e, n.concat([o.value]), i), delete s[o.value.outlet] }), Object.entries(s).forEach(([o, c]) => Qe(c, e.getContext(o), i)), i } function ha(t, r, e, n, i = { canDeactivateChecks: [], canActivateChecks: [] }) { let s = t.value, o = r ? r.value : null, c = e ? e.getContext(t.value.outlet) : null; if (o && s.routeConfig === o.routeConfig) { let a = fa(o, s, s.routeConfig.runGuardsAndResolvers); a ? i.canActivateChecks.push(new Yt(n)) : (s.data = o.data, s._resolvedData = o._resolvedData), s.component ? Je(t, r, c ? c.children : null, n, i) : Je(t, r, e, n, i), a && c && c.outlet && c.outlet.isActivated && i.canDeactivateChecks.push(new Ce(c.outlet.component, o)) } else o && Qe(r, c, i), i.canActivateChecks.push(new Yt(n)), s.component ? Je(t, null, c ? c.children : null, n, i) : Je(t, null, e, n, i); return i } function fa(t, r, e) { if (typeof e == "function") return e(t, r); switch (e) { case "pathParamsChange": return !fe(t.url, r.url); case "pathParamsOrQueryParamsChange": return !fe(t.url, r.url) || !G(t.queryParams, r.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !sn(t, r) || !G(t.queryParams, r.queryParams); case "paramsChange": default: return !sn(t, r) } } function Qe(t, r, e) { let n = be(t), i = t.value; Object.entries(n).forEach(([s, o]) => { i.component ? r ? Qe(o, r.children.getContext(s), e) : Qe(o, null, e) : Qe(o, r, e) }), i.component ? r && r.outlet && r.outlet.isActivated ? e.canDeactivateChecks.push(new Ce(r.outlet.component, i)) : e.canDeactivateChecks.push(new Ce(null, i)) : e.canDeactivateChecks.push(new Ce(null, i)) } function ht(t) { return typeof t == "function" } function pa(t) { return typeof t == "boolean" } function ga(t) { return t && ht(t.canLoad) } function ma(t) { return t && ht(t.canActivate) } function va(t) { return t && ht(t.canActivateChild) } function ya(t) { return t && ht(t.canDeactivate) } function wa(t) { return t && ht(t.canMatch) } function hs(t) { return t instanceof Tn || t?.name === "EmptyError" } var jt = Symbol("INITIAL_VALUE"); function Oe() { return k(t => gt(t.map(r => r.pipe(me(1), Mn(jt)))).pipe(S(r => { for (let e of r) if (e !== !0) { if (e === jt) return jt; if (e === !1 || Ra(e)) return e } return !0 }), H(r => r !== jt), me(1))) } function Ra(t) { return pe(t) || t instanceof it } function Sa(t, r) { return U(e => { let { targetSnapshot: n, currentSnapshot: i, guards: { canActivateChecks: s, canDeactivateChecks: o } } = e; return o.length === 0 && s.length === 0 ? p(P(h({}, e), { guardsResult: !0 })) : ba(o, n, i, t).pipe(U(c => c && pa(c) ? Ta(n, s, t, r) : p(c)), S(c => P(h({}, e), { guardsResult: c }))) }) } function ba(t, r, e, n) { return O(t).pipe(U(i => Ma(i.component, i.route, e, r, n)), te(i => i !== !0, !0)) } function Ta(t, r, e, n) { return O(r).pipe(ee(i => En(Ca(i.route.parent, n), Ea(i.route, n), Aa(t, i.path, e), Ia(t, i.route, e))), te(i => i !== !0, !0)) } function Ea(t, r) { return t !== null && r && r(new Qr(t)), p(!0) } function Ca(t, r) { return t !== null && r && r(new Kr(t)), p(!0) } function Ia(t, r, e) { let n = r.routeConfig ? r.routeConfig.canActivate : null; if (!n || n.length === 0) return p(!0); let i = n.map(s => or(() => { let o = ut(r) ?? e, c = Pe(s, o), a = ma(c) ? c.canActivate(r, t) : $(o, () => c(r, t)); return ae(a).pipe(te()) })); return p(i).pipe(Oe()) } function Aa(t, r, e) { let n = r[r.length - 1], s = r.slice(0, r.length - 1).reverse().map(o => da(o)).filter(o => o !== null).map(o => or(() => { let c = o.guards.map(a => { let l = ut(o.node) ?? e, u = Pe(a, l), d = va(u) ? u.canActivateChild(n, t) : $(l, () => u(n, t)); return ae(d).pipe(te()) }); return p(c).pipe(Oe()) })); return p(s).pipe(Oe()) } function Ma(t, r, e, n, i) { let s = r && r.routeConfig ? r.routeConfig.canDeactivate : null; if (!s || s.length === 0) return p(!0); let o = s.map(c => { let a = ut(r) ?? i, l = Pe(c, a), u = ya(l) ? l.canDeactivate(t, r, e, n) : $(a, () => l(t, r, e, n)); return ae(u).pipe(te()) }); return p(o).pipe(Oe()) } function Da(t, r, e, n) { let i = r.canLoad; if (i === void 0 || i.length === 0) return p(!0); let s = i.map(o => { let c = Pe(o, t), a = ga(c) ? c.canLoad(r, e) : $(t, () => c(r, e)); return ae(a) }); return p(s).pipe(Oe(), fs(n)) } function fs(t) { return Sn(M(r => { if (typeof r != "boolean") throw Kt(t, r) }), S(r => r === !0)) } function Oa(t, r, e, n) { let i = r.canMatch; if (!i || i.length === 0) return p(!0); let s = i.map(o => { let c = Pe(o, t), a = wa(c) ? c.canMatch(r, e) : $(t, () => c(r, e)); return ae(a) }); return p(s).pipe(Oe(), fs(n)) } var st = class { segmentGroup; constructor(r) { this.segmentGroup = r || null } }, ot = class extends Error { urlTree; constructor(r) { super(), this.urlTree = r } }; function Se(t) { return Ue(new st(t)) } function Pa(t) { return Ue(new C(4e3, !1)) } function Na(t) { return Ue(us(!1, _.GuardRejected)) } var cn = class { urlSerializer; urlTree; constructor(r, e) { this.urlSerializer = r, this.urlTree = e } lineralizeSegments(r, e) { let n = [], i = e.root; for (; ;) { if (n = n.concat(i.segments), i.numberOfChildren === 0) return p(n); if (i.numberOfChildren > 1 || !i.children[g]) return Pa(`${r.redirectTo}`); i = i.children[g] } } applyRedirectCommands(r, e, n, i, s) { if (typeof e != "string") { let c = e, { queryParams: a, fragment: l, routeConfig: u, url: d, outlet: m, params: b, data: A, title: R } = i, y = $(s, () => c({ params: b, data: A, queryParams: a, fragment: l, routeConfig: u, url: d, outlet: m, title: R })); if (y instanceof Z) throw new ot(y); e = y } let o = this.applyRedirectCreateUrlTree(e, this.urlSerializer.parse(e), r, n); if (e[0] === "/") throw new ot(o); return o } applyRedirectCreateUrlTree(r, e, n, i) { let s = this.createSegmentGroup(r, e.root, n, i); return new Z(s, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment) } createQueryParams(r, e) { let n = {}; return Object.entries(r).forEach(([i, s]) => { if (typeof s == "string" && s[0] === ":") { let c = s.substring(1); n[i] = e[c] } else n[i] = s }), n } createSegmentGroup(r, e, n, i) { let s = this.createSegments(r, e.segments, n, i), o = {}; return Object.entries(e.children).forEach(([c, a]) => { o[c] = this.createSegmentGroup(r, a, n, i) }), new T(s, o) } createSegments(r, e, n, i) { return e.map(s => s.path[0] === ":" ? this.findPosParam(r, s, i) : this.findOrReturn(s, n)) } findPosParam(r, e, n) { let i = n[e.path.substring(1)]; if (!i) throw new C(4001, !1); return i } findOrReturn(r, e) { let n = 0; for (let i of e) { if (i.path === r.path) return e.splice(n), i; n++ } return r } }, ln = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} }; function xa(t, r, e, n, i) { let s = ps(t, r, e); return s.matched ? (n = ea(r, n), Oa(n, r, e, i).pipe(S(o => o === !0 ? s : h({}, ln)))) : p(s) } function ps(t, r, e) { if (r.path === "**") return Ua(e); if (r.path === "") return r.pathMatch === "full" && (t.hasChildren() || e.length > 0) ? h({}, ln) : { matched: !0, consumedSegments: [], remainingSegments: e, parameters: {}, positionalParamSegments: {} }; let i = (r.matcher || Mo)(e, t, r); if (!i) return h({}, ln); let s = {}; Object.entries(i.posParams ?? {}).forEach(([c, a]) => { s[c] = a.path }); let o = i.consumed.length > 0 ? h(h({}, s), i.consumed[i.consumed.length - 1].parameters) : s; return { matched: !0, consumedSegments: i.consumed, remainingSegments: e.slice(i.consumed.length), parameters: o, positionalParamSegments: i.posParams ?? {} } } function Ua(t) { return { matched: !0, parameters: t.length > 0 ? Hi(t).parameters : {}, consumedSegments: t, remainingSegments: [], positionalParamSegments: {} } } function Fi(t, r, e, n) { return e.length > 0 && _a(t, e, n) ? { segmentGroup: new T(r, La(n, new T(e, t.children))), slicedSegments: [] } : e.length === 0 && ja(t, e, n) ? { segmentGroup: new T(t.segments, ka(t, e, n, t.children)), slicedSegments: e } : { segmentGroup: new T(t.segments, t.children), slicedSegments: e } } function ka(t, r, e, n) { let i = {}; for (let s of e) if (tr(t, r, s) && !n[B(s)]) { let o = new T([], {}); i[B(s)] = o } return h(h({}, n), i) } function La(t, r) { let e = {}; e[g] = r; for (let n of t) if (n.path === "" && B(n) !== g) { let i = new T([], {}); e[B(n)] = i } return e } function _a(t, r, e) { return e.some(n => tr(t, r, n) && B(n) !== g) } function ja(t, r, e) { return e.some(n => tr(t, r, n)) } function tr(t, r, e) { return (t.hasChildren() || r.length > 0) && e.pathMatch === "full" ? !1 : e.path === "" } function $a(t, r, e) { return r.length === 0 && !t.children[e] } var un = class { }; function Fa(t, r, e, n, i, s, o = "emptyOnly") { return new dn(t, r, e, n, i, o, s).recognize() } var za = 31, dn = class { injector; configLoader; rootComponentType; config; urlTree; paramsInheritanceStrategy; urlSerializer; applyRedirects; absoluteRedirectCount = 0; allowRedirects = !0; constructor(r, e, n, i, s, o, c) { this.injector = r, this.configLoader = e, this.rootComponentType = n, this.config = i, this.urlTree = s, this.paramsInheritanceStrategy = o, this.urlSerializer = c, this.applyRedirects = new cn(this.urlSerializer, this.urlTree) } noMatchError(r) { return new C(4002, `'${r.segmentGroup}'`) } recognize() { let r = Fi(this.urlTree.root, [], [], this.config).segmentGroup; return this.match(r).pipe(S(({ children: e, rootSnapshot: n }) => { let i = new L(n, e), s = new Zt("", i), o = Ho(n, [], this.urlTree.queryParams, this.urlTree.fragment); return o.queryParams = this.urlTree.queryParams, s.url = this.urlSerializer.serialize(o), { state: s, tree: o } })) } match(r) { let e = new Ee([], Object.freeze({}), Object.freeze(h({}, this.urlTree.queryParams)), this.urlTree.fragment, Object.freeze({}), g, this.rootComponentType, null, {}); return this.processSegmentGroup(this.injector, this.config, r, g, e).pipe(S(n => ({ children: n, rootSnapshot: e })), ge(n => { if (n instanceof ot) return this.urlTree = n.urlTree, this.match(n.urlTree.root); throw n instanceof st ? this.noMatchError(n) : n })) } processSegmentGroup(r, e, n, i, s) { return n.segments.length === 0 && n.hasChildren() ? this.processChildren(r, e, n, s) : this.processSegment(r, e, n, n.segments, i, !0, s).pipe(S(o => o instanceof L ? [o] : [])) } processChildren(r, e, n, i) { let s = []; for (let o of Object.keys(n.children)) o === "primary" ? s.unshift(o) : s.push(o); return O(s).pipe(ee(o => { let c = n.children[o], a = ta(e, o); return this.processSegmentGroup(r, a, c, o, i) }), An((o, c) => (o.push(...c), o)), ar(null), In(), U(o => { if (o === null) return Se(n); let c = gs(o); return Ba(c), p(c) })) } processSegment(r, e, n, i, s, o, c) { return O(e).pipe(ee(a => this.processSegmentAgainstRoute(a._injector ?? r, e, a, n, i, s, o, c).pipe(ge(l => { if (l instanceof st) return p(null); throw l }))), te(a => !!a), ge(a => { if (hs(a)) return $a(n, i, s) ? p(new un) : Se(n); throw a })) } processSegmentAgainstRoute(r, e, n, i, s, o, c, a) { return B(n) !== o && (o === g || !tr(i, s, n)) ? Se(i) : n.redirectTo === void 0 ? this.matchSegmentAgainstRoute(r, i, n, s, o, a) : this.allowRedirects && c ? this.expandSegmentAgainstRouteUsingRedirect(r, i, e, n, s, o, a) : Se(i) } expandSegmentAgainstRouteUsingRedirect(r, e, n, i, s, o, c) { let { matched: a, parameters: l, consumedSegments: u, positionalParamSegments: d, remainingSegments: m } = ps(e, i, s); if (!a) return Se(e); typeof i.redirectTo == "string" && i.redirectTo[0] === "/" && (this.absoluteRedirectCount++, this.absoluteRedirectCount > za && (this.allowRedirects = !1)); let b = new Ee(s, l, Object.freeze(h({}, this.urlTree.queryParams)), this.urlTree.fragment, zi(i), B(i), i.component ?? i._loadedComponent ?? null, i, Bi(i)), A = Jt(b, c, this.paramsInheritanceStrategy); b.params = Object.freeze(A.params), b.data = Object.freeze(A.data); let R = this.applyRedirects.applyRedirectCommands(u, i.redirectTo, d, b, r); return this.applyRedirects.lineralizeSegments(i, R).pipe(U(y => this.processSegment(r, n, e, y.concat(m), o, !1, c))) } matchSegmentAgainstRoute(r, e, n, i, s, o) { let c = xa(e, n, i, r, this.urlSerializer); return n.path === "**" && (e.children = {}), c.pipe(k(a => a.matched ? (r = n._injector ?? r, this.getChildConfig(r, n, i).pipe(k(({ routes: l }) => { let u = n._loadedInjector ?? r, { parameters: d, consumedSegments: m, remainingSegments: b } = a, A = new Ee(m, d, Object.freeze(h({}, this.urlTree.queryParams)), this.urlTree.fragment, zi(n), B(n), n.component ?? n._loadedComponent ?? null, n, Bi(n)), R = Jt(A, o, this.paramsInheritanceStrategy); A.params = Object.freeze(R.params), A.data = Object.freeze(R.data); let { segmentGroup: y, slicedSegments: N } = Fi(e, m, b, l); if (N.length === 0 && y.hasChildren()) return this.processChildren(u, l, y, A).pipe(S(I => new L(A, I))); if (l.length === 0 && N.length === 0) return p(new L(A, [])); let K = B(n) === s; return this.processSegment(u, l, y, N, K ? g : s, !0, A).pipe(S(I => new L(A, I instanceof L ? [I] : []))) }))) : Se(e))) } getChildConfig(r, e, n) { return e.children ? p({ routes: e.children, injector: r }) : e.loadChildren ? e._loadedRoutes !== void 0 ? p({ routes: e._loadedRoutes, injector: e._loadedInjector }) : Da(r, e, n, this.urlSerializer).pipe(U(i => i ? this.configLoader.loadChildren(r, e).pipe(M(s => { e._loadedRoutes = s.routes, e._loadedInjector = s.injector })) : Na(e))) : p({ routes: [], injector: r }) } }; function Ba(t) { t.sort((r, e) => r.value.outlet === g ? -1 : e.value.outlet === g ? 1 : r.value.outlet.localeCompare(e.value.outlet)) } function Va(t) { let r = t.value.routeConfig; return r && r.path === "" } function gs(t) { let r = [], e = new Set; for (let n of t) { if (!Va(n)) { r.push(n); continue } let i = r.find(s => n.value.routeConfig === s.value.routeConfig); i !== void 0 ? (i.children.push(...n.children), e.add(i)) : r.push(n) } for (let n of e) { let i = gs(n.children); r.push(new L(n.value, i)) } return r.filter(n => !e.has(n)) } function zi(t) { return t.data || {} } function Bi(t) { return t.resolve || {} } function qa(t, r, e, n, i, s) { return U(o => Fa(t, r, e, n, o.extractedUrl, i, s).pipe(S(({ state: c, tree: a }) => P(h({}, o), { targetSnapshot: c, urlAfterRedirects: a })))) } function Ga(t, r) { return U(e => { let { targetSnapshot: n, guards: { canActivateChecks: i } } = e; if (!i.length) return p(e); let s = new Set(i.map(a => a.route)), o = new Set; for (let a of s) if (!o.has(a)) for (let l of ms(a)) o.add(l); let c = 0; return O(o).pipe(ee(a => s.has(a) ? Wa(a, n, t, r) : (a.data = Jt(a, a.parent, t).resolve, p(void 0))), M(() => c++), cr(1), U(a => c === o.size ? p(e) : Q)) }) } function ms(t) { let r = t.children.map(e => ms(e)).flat(); return [t, ...r] } function Wa(t, r, e, n) { let i = t.routeConfig, s = t._resolve; return i?.title !== void 0 && !cs(i) && (s[ct] = i.title), Ha(s, t, r, n).pipe(S(o => (t._resolvedData = o, t.data = Jt(t, t.parent, e).resolve, null))) } function Ha(t, r, e, n) { let i = zr(t); if (i.length === 0) return p({}); let s = {}; return O(i).pipe(U(o => Xa(t[o], r, e, n).pipe(te(), M(c => { if (c instanceof it) throw Kt(new Ae, c); s[o] = c }))), cr(1), Cn(s), ge(o => hs(o) ? Q : Ue(o))) } function Xa(t, r, e, n) { let i = ut(r) ?? n, s = Pe(t, i), o = s.resolve ? s.resolve(r, e) : $(i, () => s(r, e)); return ae(o) } function $r(t) { return k(r => { let e = t(r); return e ? O(e).pipe(S(() => r)) : p(r) }) } var vs = (() => { class t { buildTitle(e) { let n, i = e.root; for (; i !== void 0;)n = this.getResolvedTitleForRoute(i) ?? n, i = i.children.find(s => s.outlet === g); return n } getResolvedTitleForRoute(e) { return e.data[ct] } static \u0275fac = function (n) { return new (n || t) }; static \u0275prov = w({ token: t, factory: () => f(Ja), providedIn: "root" }) } return t })(), Ja = (() => { class t extends vs { title; constructor(e) { super(), this.title = e } updateTitle(e) { let n = this.buildTitle(e); n !== void 0 && this.title.setTitle(n) } static \u0275fac = function (n) { return new (n || t)(v(Ui)) }; static \u0275prov = w({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), ft = new E("", { providedIn: "root", factory: () => ({}) }), Za = (() => { class t { static \u0275fac = function (n) { return new (n || t) }; static \u0275cmp = Kn({ type: t, selectors: [["ng-component"]], decls: 1, vars: 0, template: function (n, i) { n & 1 && ti(0, "router-outlet") }, dependencies: [ia], encapsulation: 2 }) } return t })(); function pn(t) { let r = t.children && t.children.map(pn), e = r ? P(h({}, t), { children: r }) : h({}, t); return !e.component && !e.loadComponent && (r || e.loadChildren) && e.outlet && e.outlet !== g && (e.component = Za), e } var at = new E(""), gn = (() => { class t { componentLoaders = new WeakMap; childrenLoaders = new WeakMap; onLoadStartListener; onLoadEndListener; compiler = f(Et); loadComponent(e) { if (this.componentLoaders.get(e)) return this.componentLoaders.get(e); if (e._loadedComponent) return p(e._loadedComponent); this.onLoadStartListener && this.onLoadStartListener(e); let n = ae(e.loadComponent()).pipe(S(ys), M(s => { this.onLoadEndListener && this.onLoadEndListener(e), e._loadedComponent = s }), ve(() => { this.componentLoaders.delete(e) })), i = new sr(n, () => new Y).pipe(ir()); return this.componentLoaders.set(e, i), i } loadChildren(e, n) { if (this.childrenLoaders.get(n)) return this.childrenLoaders.get(n); if (n._loadedRoutes) return p({ routes: n._loadedRoutes, injector: n._loadedInjector }); this.onLoadStartListener && this.onLoadStartListener(n); let s = Ka(n, this.compiler, e, this.onLoadEndListener).pipe(ve(() => { this.childrenLoaders.delete(n) })), o = new sr(s, () => new Y).pipe(ir()); return this.childrenLoaders.set(n, o), o } static \u0275fac = function (n) { return new (n || t) }; static \u0275prov = w({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); function Ka(t, r, e, n) { return ae(t.loadChildren()).pipe(S(ys), U(i => i instanceof Zn || Array.isArray(i) ? p(i) : O(r.compileModuleAsync(i))), S(i => { n && n(t); let s, o, c = !1; return Array.isArray(i) ? (o = i, c = !0) : (s = i.create(e).injector, o = s.get(at, [], { optional: !0, self: !0 }).flat()), { routes: o.map(pn), injector: s } })) } function Ya(t) { return t && typeof t == "object" && "default" in t } function ys(t) { return Ya(t) ? t.default : t } var mn = (() => { class t { static \u0275fac = function (n) { return new (n || t) }; static \u0275prov = w({ token: t, factory: () => f(Qa), providedIn: "root" }) } return t })(), Qa = (() => { class t { shouldProcessUrl(e) { return !0 } extract(e) { return e } merge(e, n) { return e } static \u0275fac = function (n) { return new (n || t) }; static \u0275prov = w({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), ws = new E(""), Rs = new E(""); function ec(t, r, e) { let n = t.get(Rs), i = t.get(x); return t.get(q).runOutsideAngular(() => { if (!i.startViewTransition || n.skipNextTransition) return n.skipNextTransition = !1, new Promise(l => setTimeout(l)); let s, o = new Promise(l => { s = l }), c = i.startViewTransition(() => (s(), tc(t))), { onViewTransitionCreated: a } = n; return a && $(t, () => a({ transition: c, from: r, to: e })), o }) } function tc(t) { return new Promise(r => { _n({ read: () => setTimeout(r) }, { injector: t }) }) } var Ss = new E(""), vn = (() => { class t { currentNavigation = null; currentTransition = null; lastSuccessfulNavigation = null; events = new Y; transitionAbortSubject = new Y; configLoader = f(gn); environmentInjector = f(le); urlSerializer = f(lt); rootContexts = f(dt); location = f(Fe); inputBindingEnabled = f(er, { optional: !0 }) !== null; titleStrategy = f(vs); options = f(ft, { optional: !0 }) || {}; paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly"; urlHandlingStrategy = f(mn); createViewTransition = f(ws, { optional: !0 }); navigationErrorHandler = f(Ss, { optional: !0 }); navigationId = 0; get hasRequestedNavigation() { return this.navigationId !== 0 } transitions; afterPreactivation = () => p(void 0); rootComponentType = null; constructor() { let e = i => this.events.next(new Jr(i)), n = i => this.events.next(new Zr(i)); this.configLoader.onLoadEndListener = n, this.configLoader.onLoadStartListener = e } complete() { this.transitions?.complete() } handleNavigationRequest(e) { let n = ++this.navigationId; this.transitions?.next(P(h(h({}, this.transitions.value), e), { id: n })) } setupNavigations(e, n, i) { return this.transitions = new j({ id: 0, currentUrlTree: n, currentRawUrl: n, extractedUrl: this.urlHandlingStrategy.extract(n), urlAfterRedirects: this.urlHandlingStrategy.extract(n), rawUrl: n, extras: {}, resolve: () => { }, reject: () => { }, promise: Promise.resolve(!0), source: Ye, restoredState: null, currentSnapshot: i.snapshot, targetSnapshot: null, currentRouterState: i, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.transitions.pipe(H(s => s.id !== 0), S(s => P(h({}, s), { extractedUrl: this.urlHandlingStrategy.extract(s.rawUrl) })), k(s => { let o = !1, c = !1; return p(s).pipe(k(a => { if (this.navigationId > s.id) return this.cancelNavigationTransition(s, "", _.SupersededByNewNavigation), Q; this.currentTransition = s, this.currentNavigation = { id: a.id, initialUrl: a.rawUrl, extractedUrl: a.extractedUrl, targetBrowserUrl: typeof a.extras.browserUrl == "string" ? this.urlSerializer.parse(a.extras.browserUrl) : a.extras.browserUrl, trigger: a.source, extras: a.extras, previousNavigation: this.lastSuccessfulNavigation ? P(h({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null }; let l = !e.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl(), u = a.extras.onSameUrlNavigation ?? e.onSameUrlNavigation; if (!l && u !== "reload") { let d = ""; return this.events.next(new se(a.id, this.urlSerializer.serialize(a.rawUrl), d, qt.IgnoredSameUrlNavigation)), a.resolve(!1), Q } if (this.urlHandlingStrategy.shouldProcessUrl(a.rawUrl)) return p(a).pipe(k(d => { let m = this.transitions?.getValue(); return this.events.next(new Me(d.id, this.urlSerializer.serialize(d.extractedUrl), d.source, d.restoredState)), m !== this.transitions?.getValue() ? Q : Promise.resolve(d) }), qa(this.environmentInjector, this.configLoader, this.rootComponentType, e.config, this.urlSerializer, this.paramsInheritanceStrategy), M(d => { s.targetSnapshot = d.targetSnapshot, s.urlAfterRedirects = d.urlAfterRedirects, this.currentNavigation = P(h({}, this.currentNavigation), { finalUrl: d.urlAfterRedirects }); let m = new Gt(d.id, this.urlSerializer.serialize(d.extractedUrl), this.urlSerializer.serialize(d.urlAfterRedirects), d.targetSnapshot); this.events.next(m) })); if (l && this.urlHandlingStrategy.shouldProcessUrl(a.currentRawUrl)) { let { id: d, extractedUrl: m, source: b, restoredState: A, extras: R } = a, y = new Me(d, this.urlSerializer.serialize(m), b, A); this.events.next(y); let N = os(this.rootComponentType).snapshot; return this.currentTransition = s = P(h({}, a), { targetSnapshot: N, urlAfterRedirects: m, extras: P(h({}, R), { skipLocationChange: !1, replaceUrl: !1 }) }), this.currentNavigation.finalUrl = m, p(s) } else { let d = ""; return this.events.next(new se(a.id, this.urlSerializer.serialize(a.extractedUrl), d, qt.IgnoredByUrlHandlingStrategy)), a.resolve(!1), Q } }), M(a => { let l = new Gr(a.id, this.urlSerializer.serialize(a.extractedUrl), this.urlSerializer.serialize(a.urlAfterRedirects), a.targetSnapshot); this.events.next(l) }), S(a => (this.currentTransition = s = P(h({}, a), { guards: ua(a.targetSnapshot, a.currentSnapshot, this.rootContexts) }), s)), Sa(this.environmentInjector, a => this.events.next(a)), M(a => { if (s.guardsResult = a.guardsResult, a.guardsResult && typeof a.guardsResult != "boolean") throw Kt(this.urlSerializer, a.guardsResult); let l = new Wr(a.id, this.urlSerializer.serialize(a.extractedUrl), this.urlSerializer.serialize(a.urlAfterRedirects), a.targetSnapshot, !!a.guardsResult); this.events.next(l) }), H(a => a.guardsResult ? !0 : (this.cancelNavigationTransition(a, "", _.GuardRejected), !1)), $r(a => { if (a.guards.canActivateChecks.length) return p(a).pipe(M(l => { let u = new Hr(l.id, this.urlSerializer.serialize(l.extractedUrl), this.urlSerializer.serialize(l.urlAfterRedirects), l.targetSnapshot); this.events.next(u) }), k(l => { let u = !1; return p(l).pipe(Ga(this.paramsInheritanceStrategy, this.environmentInjector), M({ next: () => u = !0, complete: () => { u || this.cancelNavigationTransition(l, "", _.NoDataFromResolver) } })) }), M(l => { let u = new Xr(l.id, this.urlSerializer.serialize(l.extractedUrl), this.urlSerializer.serialize(l.urlAfterRedirects), l.targetSnapshot); this.events.next(u) })) }), $r(a => { let l = u => { let d = []; u.routeConfig?.loadComponent && !u.routeConfig._loadedComponent && d.push(this.configLoader.loadComponent(u.routeConfig).pipe(M(m => { u.component = m }), S(() => { }))); for (let m of u.children) d.push(...l(m)); return d }; return gt(l(a.targetSnapshot.root)).pipe(ar(null), me(1)) }), $r(() => this.afterPreactivation()), k(() => { let { currentSnapshot: a, targetSnapshot: l } = s, u = this.createViewTransition?.(this.environmentInjector, a.root, l.root); return u ? O(u).pipe(S(() => s)) : p(s) }), S(a => { let l = sa(e.routeReuseStrategy, a.targetSnapshot, a.currentRouterState); return this.currentTransition = s = P(h({}, a), { targetRouterState: l }), this.currentNavigation.targetRouterState = l, s }), M(() => { this.events.next(new rt) }), la(this.rootContexts, e.routeReuseStrategy, a => this.events.next(a), this.inputBindingEnabled), me(1), M({ next: a => { o = !0, this.lastSuccessfulNavigation = this.currentNavigation, this.events.next(new V(a.id, this.urlSerializer.serialize(a.extractedUrl), this.urlSerializer.serialize(a.urlAfterRedirects))), this.titleStrategy?.updateTitle(a.targetRouterState.snapshot), a.resolve(!0) }, complete: () => { o = !0 } }), Dn(this.transitionAbortSubject.pipe(M(a => { throw a }))), ve(() => { !o && !c && this.cancelNavigationTransition(s, "", _.SupersededByNewNavigation), this.currentTransition?.id === s.id && (this.currentNavigation = null, this.currentTransition = null) }), ge(a => { if (c = !0, ds(a)) this.events.next(new J(s.id, this.urlSerializer.serialize(s.extractedUrl), a.message, a.cancellationCode)), ca(a) ? this.events.next(new De(a.url, a.navigationBehaviorOptions)) : s.resolve(!1); else { let l = new tt(s.id, this.urlSerializer.serialize(s.extractedUrl), a, s.targetSnapshot ?? void 0); try { let u = $(this.environmentInjector, () => this.navigationErrorHandler?.(l)); if (u instanceof it) { let { message: d, cancellationCode: m } = Kt(this.urlSerializer, u); this.events.next(new J(s.id, this.urlSerializer.serialize(s.extractedUrl), d, m)), this.events.next(new De(u.redirectTo, u.navigationBehaviorOptions)) } else throw this.events.next(l), a } catch (u) { this.options.resolveNavigationPromiseOnError ? s.resolve(!1) : s.reject(u) } } return Q })) })) } cancelNavigationTransition(e, n, i) { let s = new J(e.id, this.urlSerializer.serialize(e.extractedUrl), n, i); this.events.next(s), e.resolve(!1) } isUpdatingInternalState() { return this.currentTransition?.extractedUrl.toString() !== this.currentTransition?.currentUrlTree.toString() } isUpdatedBrowserUrl() { let e = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(!0))), n = this.currentNavigation?.targetBrowserUrl ?? this.currentNavigation?.extractedUrl; return e.toString() !== n?.toString() && !this.currentNavigation?.extras.skipLocationChange } static \u0275fac = function (n) { return new (n || t) }; static \u0275prov = w({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); function rc(t) { return t !== Ye } var nc = (() => { class t { static \u0275fac = function (n) { return new (n || t) }; static \u0275prov = w({ token: t, factory: () => f(ic), providedIn: "root" }) } return t })(), hn = class { shouldDetach(r) { return !1 } store(r, e) { } shouldAttach(r) { return !1 } retrieve(r) { return null } shouldReuseRoute(r, e) { return r.routeConfig === e.routeConfig } }, ic = (() => { class t extends hn { static \u0275fac = (() => { let e; return function (i) { return (e || (e = dr(t)))(i || t) } })(); static \u0275prov = w({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), bs = (() => { class t { static \u0275fac = function (n) { return new (n || t) }; static \u0275prov = w({ token: t, factory: () => f(sc), providedIn: "root" }) } return t })(), sc = (() => { class t extends bs { location = f(Fe); urlSerializer = f(lt); options = f(ft, { optional: !0 }) || {}; canceledNavigationResolution = this.options.canceledNavigationResolution || "replace"; urlHandlingStrategy = f(mn); urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred"; currentUrlTree = new Z; getCurrentUrlTree() { return this.currentUrlTree } rawUrlTree = this.currentUrlTree; getRawUrlTree() { return this.rawUrlTree } currentPageId = 0; lastSuccessfulId = -1; restoredState() { return this.location.getState() } get browserPageId() { return this.canceledNavigationResolution !== "computed" ? this.currentPageId : this.restoredState()?.\u0275routerPageId ?? this.currentPageId } routerState = os(null); getRouterState() { return this.routerState } stateMemento = this.createStateMemento(); createStateMemento() { return { rawUrlTree: this.rawUrlTree, currentUrlTree: this.currentUrlTree, routerState: this.routerState } } registerNonRouterCurrentEntryChangeListener(e) { return this.location.subscribe(n => { n.type === "popstate" && e(n.url, n.state) }) } handleRouterEvent(e, n) { if (e instanceof Me) this.stateMemento = this.createStateMemento(); else if (e instanceof se) this.rawUrlTree = n.initialUrl; else if (e instanceof Gt) { if (this.urlUpdateStrategy === "eager" && !n.extras.skipLocationChange) { let i = this.urlHandlingStrategy.merge(n.finalUrl, n.initialUrl); this.setBrowserUrl(n.targetBrowserUrl ?? i, n) } } else e instanceof rt ? (this.currentUrlTree = n.finalUrl, this.rawUrlTree = this.urlHandlingStrategy.merge(n.finalUrl, n.initialUrl), this.routerState = n.targetRouterState, this.urlUpdateStrategy === "deferred" && !n.extras.skipLocationChange && this.setBrowserUrl(n.targetBrowserUrl ?? this.rawUrlTree, n)) : e instanceof J && (e.code === _.GuardRejected || e.code === _.NoDataFromResolver) ? this.restoreHistory(n) : e instanceof tt ? this.restoreHistory(n, !0) : e instanceof V && (this.lastSuccessfulId = e.id, this.currentPageId = this.browserPageId) } setBrowserUrl(e, n) { let i = e instanceof Z ? this.urlSerializer.serialize(e) : e; if (this.location.isCurrentPathEqualTo(i) || n.extras.replaceUrl) { let s = this.browserPageId, o = h(h({}, n.extras.state), this.generateNgRouterState(n.id, s)); this.location.replaceState(i, "", o) } else { let s = h(h({}, n.extras.state), this.generateNgRouterState(n.id, this.browserPageId + 1)); this.location.go(i, "", s) } } restoreHistory(e, n = !1) { if (this.canceledNavigationResolution === "computed") { let i = this.browserPageId, s = this.currentPageId - i; s !== 0 ? this.location.historyGo(s) : this.currentUrlTree === e.finalUrl && s === 0 && (this.resetState(e), this.resetUrlToCurrentUrlTree()) } else this.canceledNavigationResolution === "replace" && (n && this.resetState(e), this.resetUrlToCurrentUrlTree()) } resetState(e) { this.routerState = this.stateMemento.routerState, this.currentUrlTree = this.stateMemento.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, e.finalUrl ?? this.rawUrlTree) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } generateNgRouterState(e, n) { return this.canceledNavigationResolution === "computed" ? { navigationId: e, \u0275routerPageId: n } : { navigationId: e } } static \u0275fac = (() => { let e; return function (i) { return (e || (e = dr(t)))(i || t) } })(); static \u0275prov = w({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), Ze = function (t) { return t[t.COMPLETE = 0] = "COMPLETE", t[t.FAILED = 1] = "FAILED", t[t.REDIRECTING = 2] = "REDIRECTING", t }(Ze || {}); function Ts(t, r) { t.events.pipe(H(e => e instanceof V || e instanceof J || e instanceof tt || e instanceof se), S(e => e instanceof V || e instanceof se ? Ze.COMPLETE : (e instanceof J ? e.code === _.Redirect || e.code === _.SupersededByNewNavigation : !1) ? Ze.REDIRECTING : Ze.FAILED), H(e => e !== Ze.REDIRECTING), me(1)).subscribe(() => { r() }) } var oc = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, ac = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }, W = (() => { class t { get currentUrlTree() { return this.stateManager.getCurrentUrlTree() } get rawUrlTree() { return this.stateManager.getRawUrlTree() } disposed = !1; nonRouterCurrentEntryChangeSubscription; console = f(St); stateManager = f(bs); options = f(ft, { optional: !0 }) || {}; pendingTasks = f(yt); urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred"; navigationTransitions = f(vn); urlSerializer = f(lt); location = f(Fe); urlHandlingStrategy = f(mn); _events = new Y; get events() { return this._events } get routerState() { return this.stateManager.getRouterState() } navigated = !1; routeReuseStrategy = f(nc); onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore"; config = f(at, { optional: !0 })?.flat() ?? []; componentInputBindingEnabled = !!f(er, { optional: !0 }); constructor() { this.resetConfig(this.config), this.navigationTransitions.setupNavigations(this, this.currentUrlTree, this.routerState).subscribe({ error: e => { this.console.warn(e) } }), this.subscribeToNavigationEvents() } eventsSubscription = new Rn; subscribeToNavigationEvents() { let e = this.navigationTransitions.events.subscribe(n => { try { let i = this.navigationTransitions.currentTransition, s = this.navigationTransitions.currentNavigation; if (i !== null && s !== null) { if (this.stateManager.handleRouterEvent(n, s), n instanceof J && n.code !== _.Redirect && n.code !== _.SupersededByNewNavigation) this.navigated = !0; else if (n instanceof V) this.navigated = !0; else if (n instanceof De) { let o = n.navigationBehaviorOptions, c = this.urlHandlingStrategy.merge(n.url, i.currentRawUrl), a = h({ browserUrl: i.extras.browserUrl, info: i.extras.info, skipLocationChange: i.extras.skipLocationChange, replaceUrl: i.extras.replaceUrl || this.urlUpdateStrategy === "eager" || rc(i.source) }, o); this.scheduleNavigation(c, Ye, null, a, { resolve: i.resolve, reject: i.reject, promise: i.promise }) } } lc(n) && this._events.next(n) } catch (i) { this.navigationTransitions.transitionAbortSubject.next(i) } }); this.eventsSubscription.add(e) } resetRootComponentType(e) { this.routerState.root.component = e, this.navigationTransitions.rootComponentType = e } initialNavigation() { this.setUpLocationChangeListener(), this.navigationTransitions.hasRequestedNavigation || this.navigateToSyncWithBrowser(this.location.path(!0), Ye, this.stateManager.restoredState()) } setUpLocationChangeListener() { this.nonRouterCurrentEntryChangeSubscription ??= this.stateManager.registerNonRouterCurrentEntryChangeListener((e, n) => { setTimeout(() => { this.navigateToSyncWithBrowser(e, "popstate", n) }, 0) }) } navigateToSyncWithBrowser(e, n, i) { let s = { replaceUrl: !0 }, o = i?.navigationId ? i : null; if (i) { let a = h({}, i); delete a.navigationId, delete a.\u0275routerPageId, Object.keys(a).length !== 0 && (s.state = a) } let c = this.parseUrl(e); this.scheduleNavigation(c, n, o, s) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.navigationTransitions.currentNavigation } get lastSuccessfulNavigation() { return this.navigationTransitions.lastSuccessfulNavigation } resetConfig(e) { this.config = e.map(pn), this.navigated = !1 } ngOnDestroy() { this.dispose() } dispose() { this.navigationTransitions.complete(), this.nonRouterCurrentEntryChangeSubscription && (this.nonRouterCurrentEntryChangeSubscription.unsubscribe(), this.nonRouterCurrentEntryChangeSubscription = void 0), this.disposed = !0, this.eventsSubscription.unsubscribe() } createUrlTree(e, n = {}) { let { relativeTo: i, queryParams: s, fragment: o, queryParamsHandling: c, preserveFragment: a } = n, l = a ? this.currentUrlTree.fragment : o, u = null; switch (c ?? this.options.defaultQueryParamsHandling) { case "merge": u = h(h({}, this.currentUrlTree.queryParams), s); break; case "preserve": u = this.currentUrlTree.queryParams; break; default: u = s || null }u !== null && (u = this.removeEmptyProps(u)); let d; try { let m = i ? i.snapshot : this.routerState.snapshot.root; d = rs(m) } catch { (typeof e[0] != "string" || e[0][0] !== "/") && (e = []), d = this.currentUrlTree.root } return ns(d, e, u, l ?? null) } navigateByUrl(e, n = { skipLocationChange: !1 }) { let i = pe(e) ? e : this.parseUrl(e), s = this.urlHandlingStrategy.merge(i, this.rawUrlTree); return this.scheduleNavigation(s, Ye, null, n) } navigate(e, n = { skipLocationChange: !1 }) { return cc(e), this.navigateByUrl(this.createUrlTree(e, n), n) } serializeUrl(e) { return this.urlSerializer.serialize(e) } parseUrl(e) { try { return this.urlSerializer.parse(e) } catch { return this.urlSerializer.parse("/") } } isActive(e, n) { let i; if (n === !0 ? i = h({}, oc) : n === !1 ? i = h({}, ac) : i = n, pe(e)) return ki(this.currentUrlTree, e, i); let s = this.parseUrl(e); return ki(this.currentUrlTree, s, i) } removeEmptyProps(e) { return Object.entries(e).reduce((n, [i, s]) => (s != null && (n[i] = s), n), {}) } scheduleNavigation(e, n, i, s, o) { if (this.disposed) return Promise.resolve(!1); let c, a, l; o ? (c = o.resolve, a = o.reject, l = o.promise) : l = new Promise((d, m) => { c = d, a = m }); let u = this.pendingTasks.add(); return Ts(this, () => { queueMicrotask(() => this.pendingTasks.remove(u)) }), this.navigationTransitions.handleNavigationRequest({ source: n, restoredState: i, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, rawUrl: e, extras: s, resolve: c, reject: a, promise: l, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), l.catch(d => Promise.reject(d)) } static \u0275fac = function (n) { return new (n || t) }; static \u0275prov = w({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); function cc(t) { for (let r = 0; r < t.length; r++)if (t[r] == null) throw new C(4008, !1) } function lc(t) { return !(t instanceof rt) && !(t instanceof De) } var Vi = (() => { class t { router; route; tabIndexAttribute; renderer; el; locationStrategy; href = null; target; queryParams; fragment; queryParamsHandling; state; info; relativeTo; isAnchorElement; subscription; onChanges = new Y; constructor(e, n, i, s, o, c) { this.router = e, this.route = n, this.tabIndexAttribute = i, this.renderer = s, this.el = o, this.locationStrategy = c; let a = o.nativeElement.tagName?.toLowerCase(); this.isAnchorElement = a === "a" || a === "area", this.isAnchorElement ? this.subscription = e.events.subscribe(l => { l instanceof V && this.updateHref() }) : this.setTabIndexIfNotOnNativeEl("0") } preserveFragment = !1; skipLocationChange = !1; replaceUrl = !1; setTabIndexIfNotOnNativeEl(e) { this.tabIndexAttribute != null || this.isAnchorElement || this.applyAttributeValue("tabindex", e) } ngOnChanges(e) { this.isAnchorElement && this.updateHref(), this.onChanges.next(this) } routerLinkInput = null; set routerLink(e) { e == null ? (this.routerLinkInput = null, this.setTabIndexIfNotOnNativeEl(null)) : (pe(e) ? this.routerLinkInput = e : this.routerLinkInput = Array.isArray(e) ? e : [e], this.setTabIndexIfNotOnNativeEl("0")) } onClick(e, n, i, s, o) { let c = this.urlTree; if (c === null || this.isAnchorElement && (e !== 0 || n || i || s || o || typeof this.target == "string" && this.target != "_self")) return !0; let a = { skipLocationChange: this.skipLocationChange, replaceUrl: this.replaceUrl, state: this.state, info: this.info }; return this.router.navigateByUrl(c, a), !this.isAnchorElement } ngOnDestroy() { this.subscription?.unsubscribe() } updateHref() { let e = this.urlTree; this.href = e !== null && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(e)) : null; let n = this.href === null ? null : Gn(this.href, this.el.nativeElement.tagName.toLowerCase(), "href"); this.applyAttributeValue("href", n) } applyAttributeValue(e, n) { let i = this.renderer, s = this.el.nativeElement; n !== null ? i.setAttribute(s, e, n) : i.removeAttribute(s, e) } get urlTree() { return this.routerLinkInput === null ? null : pe(this.routerLinkInput) ? this.routerLinkInput : this.router.createUrlTree(this.routerLinkInput, { relativeTo: this.relativeTo !== void 0 ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: this.preserveFragment }) } static \u0275fac = function (n) { return new (n || t)(z(W), z(oe), xn("tabindex"), z(vr), z(pr), z($e)) }; static \u0275dir = Rt({ type: t, selectors: [["", "routerLink", ""]], hostVars: 1, hostBindings: function (n, i) { n & 1 && ri("click", function (o) { return i.onClick(o.button, o.ctrlKey, o.shiftKey, o.altKey, o.metaKey) }), n & 2 && ei("target", i.target) }, inputs: { target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", state: "state", info: "info", relativeTo: "relativeTo", preserveFragment: [2, "preserveFragment", "preserveFragment", It], skipLocationChange: [2, "skipLocationChange", "skipLocationChange", It], replaceUrl: [2, "replaceUrl", "replaceUrl", It], routerLink: "routerLink" }, features: [Yn, vt] }) } return t })(), Pl = (() => { class t { router; element; renderer; cdr; link; links; classes = []; routerEventsSubscription; linkInputChangesSubscription; _isActive = !1; get isActive() { return this._isActive } routerLinkActiveOptions = { exact: !1 }; ariaCurrentWhenActive; isActiveChange = new ye; constructor(e, n, i, s, o) { this.router = e, this.element = n, this.renderer = i, this.cdr = s, this.link = o, this.routerEventsSubscription = e.events.subscribe(c => { c instanceof V && this.update() }) } ngAfterContentInit() { p(this.links.changes, p(null)).pipe(ke()).subscribe(e => { this.update(), this.subscribeToEachLinkOnChanges() }) } subscribeToEachLinkOnChanges() { this.linkInputChangesSubscription?.unsubscribe(); let e = [...this.links.toArray(), this.link].filter(n => !!n).map(n => n.onChanges); this.linkInputChangesSubscription = O(e).pipe(ke()).subscribe(n => { this._isActive !== this.isLinkActive(this.router)(n) && this.update() }) } set routerLinkActive(e) { let n = Array.isArray(e) ? e : e.split(" "); this.classes = n.filter(i => !!i) } ngOnChanges(e) { this.update() } ngOnDestroy() { this.routerEventsSubscription.unsubscribe(), this.linkInputChangesSubscription?.unsubscribe() } update() { !this.links || !this.router.navigated || queueMicrotask(() => { let e = this.hasActiveLinks(); this.classes.forEach(n => { e ? this.renderer.addClass(this.element.nativeElement, n) : this.renderer.removeClass(this.element.nativeElement, n) }), e && this.ariaCurrentWhenActive !== void 0 ? this.renderer.setAttribute(this.element.nativeElement, "aria-current", this.ariaCurrentWhenActive.toString()) : this.renderer.removeAttribute(this.element.nativeElement, "aria-current"), this._isActive !== e && (this._isActive = e, this.cdr.markForCheck(), this.isActiveChange.emit(e)) }) } isLinkActive(e) { let n = uc(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : this.routerLinkActiveOptions.exact || !1; return i => { let s = i.urlTree; return s ? e.isActive(s, n) : !1 } } hasActiveLinks() { let e = this.isLinkActive(this.router); return this.link && e(this.link) || this.links.some(e) } static \u0275fac = function (n) { return new (n || t)(z(W), z(pr), z(vr), z(Ct), z(Vi, 8)) }; static \u0275dir = Rt({ type: t, selectors: [["", "routerLinkActive", ""]], contentQueries: function (n, i, s) { if (n & 1 && ni(s, Vi, 5), n & 2) { let o; ii(o = si()) && (i.links = o) } }, inputs: { routerLinkActiveOptions: "routerLinkActiveOptions", ariaCurrentWhenActive: "ariaCurrentWhenActive", routerLinkActive: "routerLinkActive" }, outputs: { isActiveChange: "isActiveChange" }, exportAs: ["routerLinkActive"], features: [vt] }) } return t })(); function uc(t) { return !!t.paths } var Qt = class { }; var dc = (() => { class t { router; injector; preloadingStrategy; loader; subscription; constructor(e, n, i, s, o) { this.router = e, this.injector = i, this.preloadingStrategy = s, this.loader = o } setUpPreloading() { this.subscription = this.router.events.pipe(H(e => e instanceof V), ee(() => this.preload())).subscribe(() => { }) } preload() { return this.processRoutes(this.injector, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(e, n) { let i = []; for (let s of n) { s.providers && !s._injector && (s._injector = yr(s.providers, e, `Route: ${s.path}`)); let o = s._injector ?? e, c = s._loadedInjector ?? o; (s.loadChildren && !s._loadedRoutes && s.canLoad === void 0 || s.loadComponent && !s._loadedComponent) && i.push(this.preloadConfig(o, s)), (s.children || s._loadedRoutes) && i.push(this.processRoutes(c, s.children ?? s._loadedRoutes)) } return O(i).pipe(ke()) } preloadConfig(e, n) { return this.preloadingStrategy.preload(n, () => { let i; n.loadChildren && n.canLoad === void 0 ? i = this.loader.loadChildren(e, n) : i = p(null); let s = i.pipe(U(o => o === null ? p(void 0) : (n._loadedRoutes = o.routes, n._loadedInjector = o.injector, this.processRoutes(o.injector ?? e, o.routes)))); if (n.loadComponent && !n._loadedComponent) { let o = this.loader.loadComponent(n); return O([s, o]).pipe(ke()) } else return s }) } static \u0275fac = function (n) { return new (n || t)(v(W), v(Et), v(le), v(Qt), v(gn)) }; static \u0275prov = w({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), Es = new E(""), hc = (() => { class t { urlSerializer; transitions; viewportScroller; zone; options; routerEventsSubscription; scrollEventsSubscription; lastId = 0; lastSource = "imperative"; restoredId = 0; store = {}; constructor(e, n, i, s, o = {}) { this.urlSerializer = e, this.transitions = n, this.viewportScroller = i, this.zone = s, this.options = o, o.scrollPositionRestoration ||= "disabled", o.anchorScrolling ||= "disabled" } init() { this.options.scrollPositionRestoration !== "disabled" && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.transitions.events.subscribe(e => { e instanceof Me ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = e.navigationTrigger, this.restoredId = e.restoredState ? e.restoredState.navigationId : 0) : e instanceof V ? (this.lastId = e.id, this.scheduleScrollEvent(e, this.urlSerializer.parse(e.urlAfterRedirects).fragment)) : e instanceof se && e.code === qt.IgnoredSameUrlNavigation && (this.lastSource = void 0, this.restoredId = 0, this.scheduleScrollEvent(e, this.urlSerializer.parse(e.url).fragment)) }) } consumeScrollEvents() { return this.transitions.events.subscribe(e => { e instanceof Wt && (e.position ? this.options.scrollPositionRestoration === "top" ? this.viewportScroller.scrollToPosition([0, 0]) : this.options.scrollPositionRestoration === "enabled" && this.viewportScroller.scrollToPosition(e.position) : e.anchor && this.options.anchorScrolling === "enabled" ? this.viewportScroller.scrollToAnchor(e.anchor) : this.options.scrollPositionRestoration !== "disabled" && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(e, n) { this.zone.runOutsideAngular(() => { setTimeout(() => { this.zone.run(() => { this.transitions.events.next(new Wt(e, this.lastSource === "popstate" ? this.store[this.restoredId] : null, n)) }) }, 0) }) } ngOnDestroy() { this.routerEventsSubscription?.unsubscribe(), this.scrollEventsSubscription?.unsubscribe() } static \u0275fac = function (n) { Wn() }; static \u0275prov = w({ token: t, factory: t.\u0275fac }) } return t })(); function Nl(t, ...r) { return Le([{ provide: at, multi: !0, useValue: t }, [], { provide: oe, useFactory: Cs, deps: [W] }, { provide: bt, multi: !0, useFactory: Is }, r.map(e => e.\u0275providers)]) } function Cs(t) { return t.routerState.root } function pt(t, r) { return { \u0275kind: t, \u0275providers: r } } function Is() { let t = f(hr); return r => { let e = t.get(Tt); if (r !== e.components[0]) return; let n = t.get(W), i = t.get(As); t.get(yn) === 1 && n.initialNavigation(), t.get(Ms, null, lr.Optional)?.setUpPreloading(), t.get(Es, null, lr.Optional)?.init(), n.resetRootComponentType(e.componentTypes[0]), i.closed || (i.next(), i.complete(), i.unsubscribe()) } } var As = new E("", { factory: () => new Y }), yn = new E("", { providedIn: "root", factory: () => 1 }); function fc() { return pt(2, [{ provide: yn, useValue: 0 }, { provide: wr, multi: !0, deps: [hr], useFactory: r => { let e = r.get(ui, Promise.resolve()); return () => e.then(() => new Promise(n => { let i = r.get(W), s = r.get(As); Ts(i, () => { n(!0) }), r.get(vn).afterPreactivation = () => (n(!0), s.closed ? p(void 0) : s), i.initialNavigation() })) } }]) } function pc() { return pt(3, [{ provide: wr, multi: !0, useFactory: () => { let r = f(W); return () => { r.setUpLocationChangeListener() } } }, { provide: yn, useValue: 2 }]) } var Ms = new E(""); function gc(t) { return pt(0, [{ provide: Ms, useExisting: dc }, { provide: Qt, useExisting: t }]) } function mc() { return pt(8, [$i, { provide: er, useExisting: $i }]) } function vc(t) { let r = [{ provide: ws, useValue: ec }, { provide: Rs, useValue: h({ skipNextTransition: !!t?.skipInitialTransition }, t) }]; return pt(9, r) } var qi = new E("ROUTER_FORROOT_GUARD"), yc = [Fe, { provide: lt, useClass: Ae }, W, dt, { provide: oe, useFactory: Cs, deps: [W] }, gn, []], xl = (() => { class t { constructor(e) { } static forRoot(e, n) { return { ngModule: t, providers: [yc, [], { provide: at, multi: !0, useValue: e }, { provide: qi, useFactory: bc, deps: [[W, new ur, new Pn]] }, n?.errorHandler ? { provide: Ss, useValue: n.errorHandler } : [], { provide: ft, useValue: n || {} }, n?.useHash ? Rc() : Sc(), wc(), n?.preloadingStrategy ? gc(n.preloadingStrategy).\u0275providers : [], n?.initialNavigation ? Tc(n) : [], n?.bindToComponentInputs ? mc().\u0275providers : [], n?.enableViewTransitions ? vc().\u0275providers : [], Ec()] } } static forChild(e) { return { ngModule: t, providers: [{ provide: at, multi: !0, useValue: e }] } } static \u0275fac = function (n) { return new (n || t)(v(qi, 8)) }; static \u0275mod = wt({ type: t }); static \u0275inj = mt({}) } return t })(); function wc() { return { provide: Es, useFactory: () => { let t = f(pi), r = f(q), e = f(ft), n = f(vn), i = f(lt); return e.scrollOffset && t.setOffset(e.scrollOffset), new hc(i, n, t, r, e) } } } function Rc() { return { provide: $e, useClass: hi } } function Sc() { return { provide: $e, useClass: di } } function bc(t) { return "guarded" } function Tc(t) { return [t.initialNavigation === "disabled" ? pc().\u0275providers : [], t.initialNavigation === "enabledBlocking" ? fc().\u0275providers : []] } var Gi = new E(""); function Ec() { return [{ provide: Gi, useFactory: Is }, { provide: bt, multi: !0, useExisting: Gi }] } var Ds = { ApiUrl: "http://192.168.1.54:8010/api", Url: "http://192.168.1.54:8010" }; var Cc = `${Ds.ApiUrl}/Admins`, Os = class t { _http = f(Ar); constructor() { } userSignal = Jn(this.token); get user() { return this.userSignal.asReadonly() } get token() { return localStorage.getItem("token") } login(r) { return this._http.post(`${Cc}/LoginAdmin`, r).pipe(M(e => { e.success && (this.cacheUser(e.data), this.userSignal.set(e.data?.token)) })) } cacheUser(r) { localStorage.setItem("token", r.token) } logout() { localStorage.removeItem("token"), this.userSignal.set(null) } static \u0275fac = function (e) { return new (e || t) }; static \u0275prov = w({ token: t, factory: t.\u0275fac, providedIn: "root" }) }; export { ne as a, ie as b, Ar as c, $c as d, Fc as e, Ai as f, dl as g, Co as h, oe as i, ia as j, W as k, Vi as l, Pl as m, Nl as n, vc as o, xl as p, Ds as q, Os as r };
